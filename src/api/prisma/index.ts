// Code generated by Prisma (prisma@1.18.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { IResolvers } from "graphql-tools/dist/Interfaces";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  activity: (where?: ActivityWhereInput) => Promise<boolean>;
  address: (where?: AddressWhereInput) => Promise<boolean>;
  article: (where?: ArticleWhereInput) => Promise<boolean>;
  banquete: (where?: BanqueteWhereInput) => Promise<boolean>;
  bussinessTrip: (where?: BussinessTripWhereInput) => Promise<boolean>;
  contact: (where?: ContactWhereInput) => Promise<boolean>;
  document: (where?: DocumentWhereInput) => Promise<boolean>;
  documentProcedure: (where?: DocumentProcedureWhereInput) => Promise<boolean>;
  entity: (where?: EntityWhereInput) => Promise<boolean>;
  evaluationProcedure: (
    where?: EvaluationProcedureWhereInput
  ) => Promise<boolean>;
  item: (where?: ItemWhereInput) => Promise<boolean>;
  itemProcedure: (where?: ItemProcedureWhereInput) => Promise<boolean>;
  location: (where?: LocationWhereInput) => Promise<boolean>;
  partyEntity: (where?: PartyEntityWhereInput) => Promise<boolean>;
  partyMembership: (where?: PartyMembershipWhereInput) => Promise<boolean>;
  person: (where?: PersonWhereInput) => Promise<boolean>;
  procedure: (where?: ProcedureWhereInput) => Promise<boolean>;
  promotionProcedure: (
    where?: PromotionProcedureWhereInput
  ) => Promise<boolean>;
  storage: (where?: StorageWhereInput) => Promise<boolean>;
  transaction: (where?: TransactionWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  vacation: (where?: VacationWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;
  $getAbstractResolvers(filterSchema?: GraphQLSchema | string): IResolvers;

  /**
   * Queries
   */

  activity: (where: ActivityWhereUniqueInput) => Activity;
  activities: (
    args?: {
      where?: ActivityWhereInput;
      orderBy?: ActivityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ActivityNode>;
  activitiesConnection: (
    args?: {
      where?: ActivityWhereInput;
      orderBy?: ActivityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ActivityConnection;
  address: (where: AddressWhereUniqueInput) => Address;
  addresses: (
    args?: {
      where?: AddressWhereInput;
      orderBy?: AddressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<AddressNode>;
  addressesConnection: (
    args?: {
      where?: AddressWhereInput;
      orderBy?: AddressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AddressConnection;
  article: (where: ArticleWhereUniqueInput) => Article;
  articles: (
    args?: {
      where?: ArticleWhereInput;
      orderBy?: ArticleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ArticleNode>;
  articlesConnection: (
    args?: {
      where?: ArticleWhereInput;
      orderBy?: ArticleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ArticleConnection;
  banquete: (where: BanqueteWhereUniqueInput) => Banquete;
  banquetes: (
    args?: {
      where?: BanqueteWhereInput;
      orderBy?: BanqueteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<BanqueteNode>;
  banquetesConnection: (
    args?: {
      where?: BanqueteWhereInput;
      orderBy?: BanqueteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BanqueteConnection;
  bussinessTrip: (where: BussinessTripWhereUniqueInput) => BussinessTrip;
  bussinessTrips: (
    args?: {
      where?: BussinessTripWhereInput;
      orderBy?: BussinessTripOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<BussinessTripNode>;
  bussinessTripsConnection: (
    args?: {
      where?: BussinessTripWhereInput;
      orderBy?: BussinessTripOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BussinessTripConnection;
  contact: (where: ContactWhereUniqueInput) => Contact;
  contacts: (
    args?: {
      where?: ContactWhereInput;
      orderBy?: ContactOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ContactNode>;
  contactsConnection: (
    args?: {
      where?: ContactWhereInput;
      orderBy?: ContactOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ContactConnection;
  document: (where: DocumentWhereUniqueInput) => Document;
  documents: (
    args?: {
      where?: DocumentWhereInput;
      orderBy?: DocumentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<DocumentNode>;
  documentsConnection: (
    args?: {
      where?: DocumentWhereInput;
      orderBy?: DocumentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DocumentConnection;
  documentProcedure: (
    where: DocumentProcedureWhereUniqueInput
  ) => DocumentProcedure;
  documentProcedures: (
    args?: {
      where?: DocumentProcedureWhereInput;
      orderBy?: DocumentProcedureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<DocumentProcedureNode>;
  documentProceduresConnection: (
    args?: {
      where?: DocumentProcedureWhereInput;
      orderBy?: DocumentProcedureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DocumentProcedureConnection;
  entity: (where: EntityWhereUniqueInput) => Entity;
  entities: (
    args?: {
      where?: EntityWhereInput;
      orderBy?: EntityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<EntityNode>;
  entitiesConnection: (
    args?: {
      where?: EntityWhereInput;
      orderBy?: EntityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => EntityConnection;
  evaluationProcedure: (
    where: EvaluationProcedureWhereUniqueInput
  ) => EvaluationProcedure;
  evaluationProcedures: (
    args?: {
      where?: EvaluationProcedureWhereInput;
      orderBy?: EvaluationProcedureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<EvaluationProcedureNode>;
  evaluationProceduresConnection: (
    args?: {
      where?: EvaluationProcedureWhereInput;
      orderBy?: EvaluationProcedureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => EvaluationProcedureConnection;
  item: (where: ItemWhereUniqueInput) => Item;
  items: (
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ItemNode>;
  itemsConnection: (
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ItemConnection;
  itemProcedure: (where: ItemProcedureWhereUniqueInput) => ItemProcedure;
  itemProcedures: (
    args?: {
      where?: ItemProcedureWhereInput;
      orderBy?: ItemProcedureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ItemProcedureNode>;
  itemProceduresConnection: (
    args?: {
      where?: ItemProcedureWhereInput;
      orderBy?: ItemProcedureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ItemProcedureConnection;
  location: (where: LocationWhereUniqueInput) => Location;
  locations: (
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<LocationNode>;
  locationsConnection: (
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LocationConnection;
  partyEntity: (where: PartyEntityWhereUniqueInput) => PartyEntity;
  partyEntities: (
    args?: {
      where?: PartyEntityWhereInput;
      orderBy?: PartyEntityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PartyEntityNode>;
  partyEntitiesConnection: (
    args?: {
      where?: PartyEntityWhereInput;
      orderBy?: PartyEntityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PartyEntityConnection;
  partyMembership: (where: PartyMembershipWhereUniqueInput) => PartyMembership;
  partyMemberships: (
    args?: {
      where?: PartyMembershipWhereInput;
      orderBy?: PartyMembershipOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PartyMembershipNode>;
  partyMembershipsConnection: (
    args?: {
      where?: PartyMembershipWhereInput;
      orderBy?: PartyMembershipOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PartyMembershipConnection;
  person: (where: PersonWhereUniqueInput) => Person;
  persons: (
    args?: {
      where?: PersonWhereInput;
      orderBy?: PersonOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PersonNode>;
  personsConnection: (
    args?: {
      where?: PersonWhereInput;
      orderBy?: PersonOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PersonConnection;
  procedure: (where: ProcedureWhereUniqueInput) => Procedure;
  procedures: (
    args?: {
      where?: ProcedureWhereInput;
      orderBy?: ProcedureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProcedureNode>;
  proceduresConnection: (
    args?: {
      where?: ProcedureWhereInput;
      orderBy?: ProcedureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProcedureConnection;
  promotionProcedure: (
    where: PromotionProcedureWhereUniqueInput
  ) => PromotionProcedure;
  promotionProcedures: (
    args?: {
      where?: PromotionProcedureWhereInput;
      orderBy?: PromotionProcedureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PromotionProcedureNode>;
  promotionProceduresConnection: (
    args?: {
      where?: PromotionProcedureWhereInput;
      orderBy?: PromotionProcedureOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PromotionProcedureConnection;
  storage: (where: StorageWhereUniqueInput) => Storage;
  storages: (
    args?: {
      where?: StorageWhereInput;
      orderBy?: StorageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<StorageNode>;
  storagesConnection: (
    args?: {
      where?: StorageWhereInput;
      orderBy?: StorageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => StorageConnection;
  transaction: (where: TransactionWhereUniqueInput) => Transaction;
  transactions: (
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<TransactionNode>;
  transactionsConnection: (
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TransactionConnection;
  user: (where: UserWhereUniqueInput) => User;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserNode>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnection;
  vacation: (where: VacationWhereUniqueInput) => Vacation;
  vacations: (
    args?: {
      where?: VacationWhereInput;
      orderBy?: VacationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<VacationNode>;
  vacationsConnection: (
    args?: {
      where?: VacationWhereInput;
      orderBy?: VacationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VacationConnection;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createActivity: (data: ActivityCreateInput) => Activity;
  updateActivity: (
    args: { data: ActivityUpdateInput; where: ActivityWhereUniqueInput }
  ) => Activity;
  updateManyActivities: (
    args: { data: ActivityUpdateInput; where?: ActivityWhereInput }
  ) => BatchPayload;
  upsertActivity: (
    args: {
      where: ActivityWhereUniqueInput;
      create: ActivityCreateInput;
      update: ActivityUpdateInput;
    }
  ) => Activity;
  deleteActivity: (where: ActivityWhereUniqueInput) => Activity;
  deleteManyActivities: (where?: ActivityWhereInput) => BatchPayload;
  createAddress: (data: AddressCreateInput) => Address;
  updateAddress: (
    args: { data: AddressUpdateInput; where: AddressWhereUniqueInput }
  ) => Address;
  updateManyAddresses: (
    args: { data: AddressUpdateInput; where?: AddressWhereInput }
  ) => BatchPayload;
  upsertAddress: (
    args: {
      where: AddressWhereUniqueInput;
      create: AddressCreateInput;
      update: AddressUpdateInput;
    }
  ) => Address;
  deleteAddress: (where: AddressWhereUniqueInput) => Address;
  deleteManyAddresses: (where?: AddressWhereInput) => BatchPayload;
  createArticle: (data: ArticleCreateInput) => Article;
  updateArticle: (
    args: { data: ArticleUpdateInput; where: ArticleWhereUniqueInput }
  ) => Article;
  updateManyArticles: (
    args: { data: ArticleUpdateInput; where?: ArticleWhereInput }
  ) => BatchPayload;
  upsertArticle: (
    args: {
      where: ArticleWhereUniqueInput;
      create: ArticleCreateInput;
      update: ArticleUpdateInput;
    }
  ) => Article;
  deleteArticle: (where: ArticleWhereUniqueInput) => Article;
  deleteManyArticles: (where?: ArticleWhereInput) => BatchPayload;
  createBanquete: (data: BanqueteCreateInput) => Banquete;
  updateBanquete: (
    args: { data: BanqueteUpdateInput; where: BanqueteWhereUniqueInput }
  ) => Banquete;
  updateManyBanquetes: (
    args: { data: BanqueteUpdateInput; where?: BanqueteWhereInput }
  ) => BatchPayload;
  upsertBanquete: (
    args: {
      where: BanqueteWhereUniqueInput;
      create: BanqueteCreateInput;
      update: BanqueteUpdateInput;
    }
  ) => Banquete;
  deleteBanquete: (where: BanqueteWhereUniqueInput) => Banquete;
  deleteManyBanquetes: (where?: BanqueteWhereInput) => BatchPayload;
  createBussinessTrip: (data: BussinessTripCreateInput) => BussinessTrip;
  updateBussinessTrip: (
    args: {
      data: BussinessTripUpdateInput;
      where: BussinessTripWhereUniqueInput;
    }
  ) => BussinessTrip;
  updateManyBussinessTrips: (
    args: { data: BussinessTripUpdateInput; where?: BussinessTripWhereInput }
  ) => BatchPayload;
  upsertBussinessTrip: (
    args: {
      where: BussinessTripWhereUniqueInput;
      create: BussinessTripCreateInput;
      update: BussinessTripUpdateInput;
    }
  ) => BussinessTrip;
  deleteBussinessTrip: (where: BussinessTripWhereUniqueInput) => BussinessTrip;
  deleteManyBussinessTrips: (where?: BussinessTripWhereInput) => BatchPayload;
  createContact: (data: ContactCreateInput) => Contact;
  updateContact: (
    args: { data: ContactUpdateInput; where: ContactWhereUniqueInput }
  ) => Contact;
  updateManyContacts: (
    args: { data: ContactUpdateInput; where?: ContactWhereInput }
  ) => BatchPayload;
  upsertContact: (
    args: {
      where: ContactWhereUniqueInput;
      create: ContactCreateInput;
      update: ContactUpdateInput;
    }
  ) => Contact;
  deleteContact: (where: ContactWhereUniqueInput) => Contact;
  deleteManyContacts: (where?: ContactWhereInput) => BatchPayload;
  createDocument: (data: DocumentCreateInput) => Document;
  updateDocument: (
    args: { data: DocumentUpdateInput; where: DocumentWhereUniqueInput }
  ) => Document;
  updateManyDocuments: (
    args: { data: DocumentUpdateInput; where?: DocumentWhereInput }
  ) => BatchPayload;
  upsertDocument: (
    args: {
      where: DocumentWhereUniqueInput;
      create: DocumentCreateInput;
      update: DocumentUpdateInput;
    }
  ) => Document;
  deleteDocument: (where: DocumentWhereUniqueInput) => Document;
  deleteManyDocuments: (where?: DocumentWhereInput) => BatchPayload;
  createDocumentProcedure: (
    data: DocumentProcedureCreateInput
  ) => DocumentProcedure;
  updateDocumentProcedure: (
    args: {
      data: DocumentProcedureUpdateInput;
      where: DocumentProcedureWhereUniqueInput;
    }
  ) => DocumentProcedure;
  updateManyDocumentProcedures: (
    args: {
      data: DocumentProcedureUpdateInput;
      where?: DocumentProcedureWhereInput;
    }
  ) => BatchPayload;
  upsertDocumentProcedure: (
    args: {
      where: DocumentProcedureWhereUniqueInput;
      create: DocumentProcedureCreateInput;
      update: DocumentProcedureUpdateInput;
    }
  ) => DocumentProcedure;
  deleteDocumentProcedure: (
    where: DocumentProcedureWhereUniqueInput
  ) => DocumentProcedure;
  deleteManyDocumentProcedures: (
    where?: DocumentProcedureWhereInput
  ) => BatchPayload;
  createEntity: (data: EntityCreateInput) => Entity;
  updateEntity: (
    args: { data: EntityUpdateInput; where: EntityWhereUniqueInput }
  ) => Entity;
  updateManyEntities: (
    args: { data: EntityUpdateInput; where?: EntityWhereInput }
  ) => BatchPayload;
  upsertEntity: (
    args: {
      where: EntityWhereUniqueInput;
      create: EntityCreateInput;
      update: EntityUpdateInput;
    }
  ) => Entity;
  deleteEntity: (where: EntityWhereUniqueInput) => Entity;
  deleteManyEntities: (where?: EntityWhereInput) => BatchPayload;
  createEvaluationProcedure: (
    data: EvaluationProcedureCreateInput
  ) => EvaluationProcedure;
  updateEvaluationProcedure: (
    args: {
      data: EvaluationProcedureUpdateInput;
      where: EvaluationProcedureWhereUniqueInput;
    }
  ) => EvaluationProcedure;
  updateManyEvaluationProcedures: (
    args: {
      data: EvaluationProcedureUpdateInput;
      where?: EvaluationProcedureWhereInput;
    }
  ) => BatchPayload;
  upsertEvaluationProcedure: (
    args: {
      where: EvaluationProcedureWhereUniqueInput;
      create: EvaluationProcedureCreateInput;
      update: EvaluationProcedureUpdateInput;
    }
  ) => EvaluationProcedure;
  deleteEvaluationProcedure: (
    where: EvaluationProcedureWhereUniqueInput
  ) => EvaluationProcedure;
  deleteManyEvaluationProcedures: (
    where?: EvaluationProcedureWhereInput
  ) => BatchPayload;
  createItem: (data: ItemCreateInput) => Item;
  updateItem: (
    args: { data: ItemUpdateInput; where: ItemWhereUniqueInput }
  ) => Item;
  updateManyItems: (
    args: { data: ItemUpdateInput; where?: ItemWhereInput }
  ) => BatchPayload;
  upsertItem: (
    args: {
      where: ItemWhereUniqueInput;
      create: ItemCreateInput;
      update: ItemUpdateInput;
    }
  ) => Item;
  deleteItem: (where: ItemWhereUniqueInput) => Item;
  deleteManyItems: (where?: ItemWhereInput) => BatchPayload;
  createItemProcedure: (data: ItemProcedureCreateInput) => ItemProcedure;
  updateItemProcedure: (
    args: {
      data: ItemProcedureUpdateInput;
      where: ItemProcedureWhereUniqueInput;
    }
  ) => ItemProcedure;
  updateManyItemProcedures: (
    args: { data: ItemProcedureUpdateInput; where?: ItemProcedureWhereInput }
  ) => BatchPayload;
  upsertItemProcedure: (
    args: {
      where: ItemProcedureWhereUniqueInput;
      create: ItemProcedureCreateInput;
      update: ItemProcedureUpdateInput;
    }
  ) => ItemProcedure;
  deleteItemProcedure: (where: ItemProcedureWhereUniqueInput) => ItemProcedure;
  deleteManyItemProcedures: (where?: ItemProcedureWhereInput) => BatchPayload;
  createLocation: (data: LocationCreateInput) => Location;
  updateLocation: (
    args: { data: LocationUpdateInput; where: LocationWhereUniqueInput }
  ) => Location;
  updateManyLocations: (
    args: { data: LocationUpdateInput; where?: LocationWhereInput }
  ) => BatchPayload;
  upsertLocation: (
    args: {
      where: LocationWhereUniqueInput;
      create: LocationCreateInput;
      update: LocationUpdateInput;
    }
  ) => Location;
  deleteLocation: (where: LocationWhereUniqueInput) => Location;
  deleteManyLocations: (where?: LocationWhereInput) => BatchPayload;
  createPartyEntity: (data: PartyEntityCreateInput) => PartyEntity;
  updatePartyEntity: (
    args: { data: PartyEntityUpdateInput; where: PartyEntityWhereUniqueInput }
  ) => PartyEntity;
  updateManyPartyEntities: (
    args: { data: PartyEntityUpdateInput; where?: PartyEntityWhereInput }
  ) => BatchPayload;
  upsertPartyEntity: (
    args: {
      where: PartyEntityWhereUniqueInput;
      create: PartyEntityCreateInput;
      update: PartyEntityUpdateInput;
    }
  ) => PartyEntity;
  deletePartyEntity: (where: PartyEntityWhereUniqueInput) => PartyEntity;
  deleteManyPartyEntities: (where?: PartyEntityWhereInput) => BatchPayload;
  createPartyMembership: (data: PartyMembershipCreateInput) => PartyMembership;
  updatePartyMembership: (
    args: {
      data: PartyMembershipUpdateInput;
      where: PartyMembershipWhereUniqueInput;
    }
  ) => PartyMembership;
  updateManyPartyMemberships: (
    args: {
      data: PartyMembershipUpdateInput;
      where?: PartyMembershipWhereInput;
    }
  ) => BatchPayload;
  upsertPartyMembership: (
    args: {
      where: PartyMembershipWhereUniqueInput;
      create: PartyMembershipCreateInput;
      update: PartyMembershipUpdateInput;
    }
  ) => PartyMembership;
  deletePartyMembership: (
    where: PartyMembershipWhereUniqueInput
  ) => PartyMembership;
  deleteManyPartyMemberships: (
    where?: PartyMembershipWhereInput
  ) => BatchPayload;
  createPerson: (data: PersonCreateInput) => Person;
  updatePerson: (
    args: { data: PersonUpdateInput; where: PersonWhereUniqueInput }
  ) => Person;
  updateManyPersons: (
    args: { data: PersonUpdateInput; where?: PersonWhereInput }
  ) => BatchPayload;
  upsertPerson: (
    args: {
      where: PersonWhereUniqueInput;
      create: PersonCreateInput;
      update: PersonUpdateInput;
    }
  ) => Person;
  deletePerson: (where: PersonWhereUniqueInput) => Person;
  deleteManyPersons: (where?: PersonWhereInput) => BatchPayload;
  createProcedure: (data: ProcedureCreateInput) => Procedure;
  updateProcedure: (
    args: { data: ProcedureUpdateInput; where: ProcedureWhereUniqueInput }
  ) => Procedure;
  updateManyProcedures: (
    args: { data: ProcedureUpdateInput; where?: ProcedureWhereInput }
  ) => BatchPayload;
  upsertProcedure: (
    args: {
      where: ProcedureWhereUniqueInput;
      create: ProcedureCreateInput;
      update: ProcedureUpdateInput;
    }
  ) => Procedure;
  deleteProcedure: (where: ProcedureWhereUniqueInput) => Procedure;
  deleteManyProcedures: (where?: ProcedureWhereInput) => BatchPayload;
  createPromotionProcedure: (
    data: PromotionProcedureCreateInput
  ) => PromotionProcedure;
  updatePromotionProcedure: (
    args: {
      data: PromotionProcedureUpdateInput;
      where: PromotionProcedureWhereUniqueInput;
    }
  ) => PromotionProcedure;
  updateManyPromotionProcedures: (
    args: {
      data: PromotionProcedureUpdateInput;
      where?: PromotionProcedureWhereInput;
    }
  ) => BatchPayload;
  upsertPromotionProcedure: (
    args: {
      where: PromotionProcedureWhereUniqueInput;
      create: PromotionProcedureCreateInput;
      update: PromotionProcedureUpdateInput;
    }
  ) => PromotionProcedure;
  deletePromotionProcedure: (
    where: PromotionProcedureWhereUniqueInput
  ) => PromotionProcedure;
  deleteManyPromotionProcedures: (
    where?: PromotionProcedureWhereInput
  ) => BatchPayload;
  createStorage: (data: StorageCreateInput) => Storage;
  updateStorage: (
    args: { data: StorageUpdateInput; where: StorageWhereUniqueInput }
  ) => Storage;
  updateManyStorages: (
    args: { data: StorageUpdateInput; where?: StorageWhereInput }
  ) => BatchPayload;
  upsertStorage: (
    args: {
      where: StorageWhereUniqueInput;
      create: StorageCreateInput;
      update: StorageUpdateInput;
    }
  ) => Storage;
  deleteStorage: (where: StorageWhereUniqueInput) => Storage;
  deleteManyStorages: (where?: StorageWhereInput) => BatchPayload;
  createTransaction: (data: TransactionCreateInput) => Transaction;
  updateTransaction: (
    args: { data: TransactionUpdateInput; where: TransactionWhereUniqueInput }
  ) => Transaction;
  updateManyTransactions: (
    args: { data: TransactionUpdateInput; where?: TransactionWhereInput }
  ) => BatchPayload;
  upsertTransaction: (
    args: {
      where: TransactionWhereUniqueInput;
      create: TransactionCreateInput;
      update: TransactionUpdateInput;
    }
  ) => Transaction;
  deleteTransaction: (where: TransactionWhereUniqueInput) => Transaction;
  deleteManyTransactions: (where?: TransactionWhereInput) => BatchPayload;
  createUser: (data: UserCreateInput) => User;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => User;
  updateManyUsers: (
    args: { data: UserUpdateInput; where?: UserWhereInput }
  ) => BatchPayload;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => User;
  deleteUser: (where: UserWhereUniqueInput) => User;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayload;
  createVacation: (data: VacationCreateInput) => Vacation;
  updateVacation: (
    args: { data: VacationUpdateInput; where: VacationWhereUniqueInput }
  ) => Vacation;
  updateManyVacations: (
    args: { data: VacationUpdateInput; where?: VacationWhereInput }
  ) => BatchPayload;
  upsertVacation: (
    args: {
      where: VacationWhereUniqueInput;
      create: VacationCreateInput;
      update: VacationUpdateInput;
    }
  ) => Vacation;
  deleteVacation: (where: VacationWhereUniqueInput) => Vacation;
  deleteManyVacations: (where?: VacationWhereInput) => BatchPayload;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  activity: (
    where?: ActivitySubscriptionWhereInput
  ) => ActivitySubscriptionPayloadSubscription;
  address: (
    where?: AddressSubscriptionWhereInput
  ) => AddressSubscriptionPayloadSubscription;
  article: (
    where?: ArticleSubscriptionWhereInput
  ) => ArticleSubscriptionPayloadSubscription;
  banquete: (
    where?: BanqueteSubscriptionWhereInput
  ) => BanqueteSubscriptionPayloadSubscription;
  bussinessTrip: (
    where?: BussinessTripSubscriptionWhereInput
  ) => BussinessTripSubscriptionPayloadSubscription;
  contact: (
    where?: ContactSubscriptionWhereInput
  ) => ContactSubscriptionPayloadSubscription;
  document: (
    where?: DocumentSubscriptionWhereInput
  ) => DocumentSubscriptionPayloadSubscription;
  documentProcedure: (
    where?: DocumentProcedureSubscriptionWhereInput
  ) => DocumentProcedureSubscriptionPayloadSubscription;
  entity: (
    where?: EntitySubscriptionWhereInput
  ) => EntitySubscriptionPayloadSubscription;
  evaluationProcedure: (
    where?: EvaluationProcedureSubscriptionWhereInput
  ) => EvaluationProcedureSubscriptionPayloadSubscription;
  item: (
    where?: ItemSubscriptionWhereInput
  ) => ItemSubscriptionPayloadSubscription;
  itemProcedure: (
    where?: ItemProcedureSubscriptionWhereInput
  ) => ItemProcedureSubscriptionPayloadSubscription;
  location: (
    where?: LocationSubscriptionWhereInput
  ) => LocationSubscriptionPayloadSubscription;
  partyEntity: (
    where?: PartyEntitySubscriptionWhereInput
  ) => PartyEntitySubscriptionPayloadSubscription;
  partyMembership: (
    where?: PartyMembershipSubscriptionWhereInput
  ) => PartyMembershipSubscriptionPayloadSubscription;
  person: (
    where?: PersonSubscriptionWhereInput
  ) => PersonSubscriptionPayloadSubscription;
  procedure: (
    where?: ProcedureSubscriptionWhereInput
  ) => ProcedureSubscriptionPayloadSubscription;
  promotionProcedure: (
    where?: PromotionProcedureSubscriptionWhereInput
  ) => PromotionProcedureSubscriptionPayloadSubscription;
  storage: (
    where?: StorageSubscriptionWhereInput
  ) => StorageSubscriptionPayloadSubscription;
  transaction: (
    where?: TransactionSubscriptionWhereInput
  ) => TransactionSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  vacation: (
    where?: VacationSubscriptionWhereInput
  ) => VacationSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ItemProcedureOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "previousPlace_ASC"
  | "previousPlace_DESC"
  | "currentPlace_ASC"
  | "currentPlace_DESC"
  | "devaluation_ASC"
  | "devaluation_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AddressOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "street_ASC"
  | "street_DESC"
  | "suite_ASC"
  | "suite_DESC"
  | "area_ASC"
  | "area_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "country_ASC"
  | "country_DESC"
  | "zipcode_ASC"
  | "zipcode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "brand_ASC"
  | "brand_DESC"
  | "model_ASC"
  | "model_DESC"
  | "productionDate_ASC"
  | "productionDate_DESC"
  | "overdueDate_ASC"
  | "overdueDate_DESC"
  | "description_ASC"
  | "description_DESC"
  | "price_ASC"
  | "price_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VacationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "routes_ASC"
  | "routes_DESC"
  | "type_ASC"
  | "type_DESC"
  | "flightTicket_ASC"
  | "flightTicket_DESC"
  | "hotelRoom_ASC"
  | "hotelRoom_DESC"
  | "transport_ASC"
  | "transport_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EvaluationProcedureOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "positiveObservation_ASC"
  | "positiveObservation_DESC"
  | "negativeObservation_ASC"
  | "negativeObservation_DESC"
  | "expectation_ASC"
  | "expectation_DESC"
  | "performanceLevel_ASC"
  | "performanceLevel_DESC"
  | "proposal_ASC"
  | "proposal_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Route = "USA" | "FRANCE" | "SPAIN" | "OTHER";

export type DocumentProcedureOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "from_ASC"
  | "from_DESC"
  | "to_ASC"
  | "to_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TransactionType = "IN" | "OUT" | "OTHER";

export type EntityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "fullName_ASC"
  | "fullName_DESC"
  | "abbr_ASC"
  | "abbr_DESC"
  | "avatar_ASC"
  | "avatar_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PromotionProcedureOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "previousRank_ASC"
  | "previousRank_DESC"
  | "currentRank_ASC"
  | "currentRank_DESC"
  | "promitionDate_ASC"
  | "promitionDate_DESC"
  | "previousSalary_ASC"
  | "previousSalary_DESC"
  | "currentSalary_ASC"
  | "currentSalary_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DocumentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "mark_ASC"
  | "mark_DESC"
  | "classification_ASC"
  | "classification_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "title_ASC"
  | "title_DESC"
  | "text_ASC"
  | "text_DESC"
  | "attachment_ASC"
  | "attachment_DESC"
  | "tags_ASC"
  | "tags_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PersonOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "birthday_ASC"
  | "birthday_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ContactOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "homePhone_ASC"
  | "homePhone_DESC"
  | "officePhone_ASC"
  | "officePhone_DESC"
  | "cellPhone_ASC"
  | "cellPhone_DESC"
  | "email_ASC"
  | "email_DESC"
  | "wechat_ASC"
  | "wechat_DESC"
  | "whatsapp_ASC"
  | "whatsapp_DESC"
  | "github_ASC"
  | "github_DESC"
  | "twitter_ASC"
  | "twitter_DESC"
  | "instagram_ASC"
  | "instagram_DESC"
  | "homepage_ASC"
  | "homepage_DESC"
  | "avatar_ASC"
  | "avatar_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PartyEntityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "fullName_ASC"
  | "fullName_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BussinessTripOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "purpose_ASC"
  | "purpose_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "flightTicket_ASC"
  | "flightTicket_DESC"
  | "hotelRoom_ASC"
  | "hotelRoom_DESC"
  | "transport_ASC"
  | "transport_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type BanqueteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "applicant_ASC"
  | "applicant_DESC"
  | "purpose_ASC"
  | "purpose_DESC"
  | "date_ASC"
  | "date_DESC"
  | "description_ASC"
  | "description_DESC"
  | "total_ASC"
  | "total_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TransactionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "place_ASC"
  | "place_DESC"
  | "date_ASC"
  | "date_DESC"
  | "description_ASC"
  | "description_DESC"
  | "applicant_ASC"
  | "applicant_DESC"
  | "quantity_ASC"
  | "quantity_DESC"
  | "total_ASC"
  | "total_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "protocolId_ASC"
  | "protocolId_DESC"
  | "name_ASC"
  | "name_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "position_ASC"
  | "position_DESC"
  | "etnia_ASC"
  | "etnia_DESC"
  | "birthday_ASC"
  | "birthday_DESC"
  | "academicBackground_ASC"
  | "academicBackground_DESC"
  | "foreignLanguage_ASC"
  | "foreignLanguage_DESC"
  | "politicalRole_ASC"
  | "politicalRole_DESC"
  | "rank_ASC"
  | "rank_DESC"
  | "promotionDate_ASC"
  | "promotionDate_DESC"
  | "outRole_ASC"
  | "outRole_DESC"
  | "innerRole_ASC"
  | "innerRole_DESC"
  | "chargeOf_ASC"
  | "chargeOf_DESC"
  | "sendingEntity_ASC"
  | "sendingEntity_DESC"
  | "arrivingDate_ASC"
  | "arrivingDate_DESC"
  | "leavingDate_ASC"
  | "leavingDate_DESC"
  | "fromEntity_ASC"
  | "fromEntity_DESC"
  | "memo_ASC"
  | "memo_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProcedureOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "deadline_ASC"
  | "deadline_DESC"
  | "progress_ASC"
  | "progress_DESC"
  | "color_ASC"
  | "color_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ArticleFormat = "COMPACT" | "WIDE" | "COVER";

export type ActivityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "occurrenceDate_ASC"
  | "occurrenceDate_DESC"
  | "content_ASC"
  | "content_DESC"
  | "currentDate_ASC"
  | "currentDate_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "reportDate_ASC"
  | "reportDate_DESC"
  | "reportContent_ASC"
  | "reportContent_DESC"
  | "instructionDate_ASC"
  | "instructionDate_DESC"
  | "instruction_ASC"
  | "instruction_DESC"
  | "priority_ASC"
  | "priority_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ArticleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "author_ASC"
  | "author_DESC"
  | "title_ASC"
  | "title_DESC"
  | "isPublished_ASC"
  | "isPublished_DESC"
  | "description_ASC"
  | "description_DESC"
  | "text_ASC"
  | "text_DESC"
  | "featuredImage_ASC"
  | "featuredImage_DESC"
  | "format_ASC"
  | "format_DESC"
  | "publishDate_ASC"
  | "publishDate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PriorityLevel = "HIGH" | "MIDDLE" | "LOW";

export type PartyMembershipOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "preEnrollDate_ASC"
  | "preEnrollDate_DESC"
  | "EnrollDate_ASC"
  | "EnrollDate_DESC"
  | "registerInDate_ASC"
  | "registerInDate_DESC"
  | "registerOutDate_ASC"
  | "registerOutDate_DESC"
  | "membershipState_ASC"
  | "membershipState_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StorageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "storageName_ASC"
  | "storageName_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VacationType =
  | "ANUAL"
  | "MISSION"
  | "STUFF"
  | "PUBLICHOLIDAY"
  | "PRIVATE"
  | "OTHER";

export type LocationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "latitude_ASC"
  | "latitude_DESC"
  | "longitude_ASC"
  | "longitude_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface UserCreateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export type ActivityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface EntityUpdateWithWhereUniqueNestedInput {
  where: EntityWhereUniqueInput;
  data: EntityUpdateDataInput;
}

export interface BussinessTripCreateroutesInput {
  set?: String[] | String;
}

export interface EntityUpdateManyInput {
  create?: EntityCreateInput[] | EntityCreateInput;
  update?:
    | EntityUpdateWithWhereUniqueNestedInput[]
    | EntityUpdateWithWhereUniqueNestedInput;
  upsert?:
    | EntityUpsertWithWhereUniqueNestedInput[]
    | EntityUpsertWithWhereUniqueNestedInput;
  delete?: EntityWhereUniqueInput[] | EntityWhereUniqueInput;
  connect?: EntityWhereUniqueInput[] | EntityWhereUniqueInput;
  disconnect?: EntityWhereUniqueInput[] | EntityWhereUniqueInput;
}

export interface PartyEntityUpdateOneRequiredInput {
  create?: PartyEntityCreateInput;
  update?: PartyEntityUpdateDataInput;
  upsert?: PartyEntityUpsertNestedInput;
  connect?: PartyEntityWhereUniqueInput;
}

export type PromotionProcedureWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type AddressWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DocumentUpsertWithWhereUniqueNestedInput {
  where: DocumentWhereUniqueInput;
  update: DocumentUpdateDataInput;
  create: DocumentCreateInput;
}

export interface TransactionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TransactionWhereInput;
  AND?: TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput;
  OR?: TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput;
  NOT?: TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput;
}

export interface PromotionProcedureWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  previousRank?: String;
  previousRank_not?: String;
  previousRank_in?: String[] | String;
  previousRank_not_in?: String[] | String;
  previousRank_lt?: String;
  previousRank_lte?: String;
  previousRank_gt?: String;
  previousRank_gte?: String;
  previousRank_contains?: String;
  previousRank_not_contains?: String;
  previousRank_starts_with?: String;
  previousRank_not_starts_with?: String;
  previousRank_ends_with?: String;
  previousRank_not_ends_with?: String;
  currentRank?: String;
  currentRank_not?: String;
  currentRank_in?: String[] | String;
  currentRank_not_in?: String[] | String;
  currentRank_lt?: String;
  currentRank_lte?: String;
  currentRank_gt?: String;
  currentRank_gte?: String;
  currentRank_contains?: String;
  currentRank_not_contains?: String;
  currentRank_starts_with?: String;
  currentRank_not_starts_with?: String;
  currentRank_ends_with?: String;
  currentRank_not_ends_with?: String;
  promitionDate?: DateTimeInput;
  promitionDate_not?: DateTimeInput;
  promitionDate_in?: DateTimeInput[] | DateTimeInput;
  promitionDate_not_in?: DateTimeInput[] | DateTimeInput;
  promitionDate_lt?: DateTimeInput;
  promitionDate_lte?: DateTimeInput;
  promitionDate_gt?: DateTimeInput;
  promitionDate_gte?: DateTimeInput;
  previousSalary?: String;
  previousSalary_not?: String;
  previousSalary_in?: String[] | String;
  previousSalary_not_in?: String[] | String;
  previousSalary_lt?: String;
  previousSalary_lte?: String;
  previousSalary_gt?: String;
  previousSalary_gte?: String;
  previousSalary_contains?: String;
  previousSalary_not_contains?: String;
  previousSalary_starts_with?: String;
  previousSalary_not_starts_with?: String;
  previousSalary_ends_with?: String;
  previousSalary_not_ends_with?: String;
  currentSalary?: String;
  currentSalary_not?: String;
  currentSalary_in?: String[] | String;
  currentSalary_not_in?: String[] | String;
  currentSalary_lt?: String;
  currentSalary_lte?: String;
  currentSalary_gt?: String;
  currentSalary_gte?: String;
  currentSalary_contains?: String;
  currentSalary_not_contains?: String;
  currentSalary_starts_with?: String;
  currentSalary_not_starts_with?: String;
  currentSalary_ends_with?: String;
  currentSalary_not_ends_with?: String;
  procedureState?: ProcedureWhereInput;
  AND?: PromotionProcedureWhereInput[] | PromotionProcedureWhereInput;
  OR?: PromotionProcedureWhereInput[] | PromotionProcedureWhereInput;
  NOT?: PromotionProcedureWhereInput[] | PromotionProcedureWhereInput;
}

export interface PromotionProcedureSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PromotionProcedureWhereInput;
  AND?:
    | PromotionProcedureSubscriptionWhereInput[]
    | PromotionProcedureSubscriptionWhereInput;
  OR?:
    | PromotionProcedureSubscriptionWhereInput[]
    | PromotionProcedureSubscriptionWhereInput;
  NOT?:
    | PromotionProcedureSubscriptionWhereInput[]
    | PromotionProcedureSubscriptionWhereInput;
}

export interface DocumentUpdateDataInput {
  type?: String;
  mark?: String;
  classification?: String;
  startDate?: DateTimeInput;
  title?: String;
  text?: String;
  fromEntity?: EntityUpdateOneRequiredInput;
  sendingEntity?: EntityUpdateOneRequiredInput;
  toEntity?: EntityUpdateOneRequiredInput;
  copyEntity?: EntityUpdateOneInput;
  attachment?: String;
  tags?: String;
  author?: UserUpdateOneRequiredWithoutDocumentsInput;
}

export interface ProcedureSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProcedureWhereInput;
  AND?: ProcedureSubscriptionWhereInput[] | ProcedureSubscriptionWhereInput;
  OR?: ProcedureSubscriptionWhereInput[] | ProcedureSubscriptionWhereInput;
  NOT?: ProcedureSubscriptionWhereInput[] | ProcedureSubscriptionWhereInput;
}

export interface DocumentUpdateWithWhereUniqueNestedInput {
  where: DocumentWhereUniqueInput;
  data: DocumentUpdateDataInput;
}

export interface ArticleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  author?: String;
  author_not?: String;
  author_in?: String[] | String;
  author_not_in?: String[] | String;
  author_lt?: String;
  author_lte?: String;
  author_gt?: String;
  author_gte?: String;
  author_contains?: String;
  author_not_contains?: String;
  author_starts_with?: String;
  author_not_starts_with?: String;
  author_ends_with?: String;
  author_not_ends_with?: String;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  isPublished?: Boolean;
  isPublished_not?: Boolean;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  featuredImage?: String;
  featuredImage_not?: String;
  featuredImage_in?: String[] | String;
  featuredImage_not_in?: String[] | String;
  featuredImage_lt?: String;
  featuredImage_lte?: String;
  featuredImage_gt?: String;
  featuredImage_gte?: String;
  featuredImage_contains?: String;
  featuredImage_not_contains?: String;
  featuredImage_starts_with?: String;
  featuredImage_not_starts_with?: String;
  featuredImage_ends_with?: String;
  featuredImage_not_ends_with?: String;
  format?: ArticleFormat;
  format_not?: ArticleFormat;
  format_in?: ArticleFormat[] | ArticleFormat;
  format_not_in?: ArticleFormat[] | ArticleFormat;
  publishDate?: DateTimeInput;
  publishDate_not?: DateTimeInput;
  publishDate_in?: DateTimeInput[] | DateTimeInput;
  publishDate_not_in?: DateTimeInput[] | DateTimeInput;
  publishDate_lt?: DateTimeInput;
  publishDate_lte?: DateTimeInput;
  publishDate_gt?: DateTimeInput;
  publishDate_gte?: DateTimeInput;
  AND?: ArticleWhereInput[] | ArticleWhereInput;
  OR?: ArticleWhereInput[] | ArticleWhereInput;
  NOT?: ArticleWhereInput[] | ArticleWhereInput;
}

export interface DocumentUpdateManyInput {
  create?: DocumentCreateInput[] | DocumentCreateInput;
  update?:
    | DocumentUpdateWithWhereUniqueNestedInput[]
    | DocumentUpdateWithWhereUniqueNestedInput;
  upsert?:
    | DocumentUpsertWithWhereUniqueNestedInput[]
    | DocumentUpsertWithWhereUniqueNestedInput;
  delete?: DocumentWhereUniqueInput[] | DocumentWhereUniqueInput;
  connect?: DocumentWhereUniqueInput[] | DocumentWhereUniqueInput;
  disconnect?: DocumentWhereUniqueInput[] | DocumentWhereUniqueInput;
}

export interface PartyMembershipSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PartyMembershipWhereInput;
  AND?:
    | PartyMembershipSubscriptionWhereInput[]
    | PartyMembershipSubscriptionWhereInput;
  OR?:
    | PartyMembershipSubscriptionWhereInput[]
    | PartyMembershipSubscriptionWhereInput;
  NOT?:
    | PartyMembershipSubscriptionWhereInput[]
    | PartyMembershipSubscriptionWhereInput;
}

export interface ProcedureUpdateWithoutNextProcedureDataInput {
  name?: String;
  startDate?: DateTimeInput;
  deadline?: DateTimeInput;
  progress?: Float;
  color?: String;
  previousProcedure?: ProcedureUpdateOneWithoutPreviousProcedureInput;
  users?: UserUpdateManyInput;
  documents?: DocumentUpdateManyInput;
  entities?: EntityUpdateManyInput;
}

export interface LocationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LocationWhereInput;
  AND?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  OR?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  NOT?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
}

export type StorageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ItemProcedureSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ItemProcedureWhereInput;
  AND?:
    | ItemProcedureSubscriptionWhereInput[]
    | ItemProcedureSubscriptionWhereInput;
  OR?:
    | ItemProcedureSubscriptionWhereInput[]
    | ItemProcedureSubscriptionWhereInput;
  NOT?:
    | ItemProcedureSubscriptionWhereInput[]
    | ItemProcedureSubscriptionWhereInput;
}

export interface ProcedureUpdateOneWithoutNextProcedureInput {
  create?: ProcedureCreateWithoutNextProcedureInput;
  update?: ProcedureUpdateWithoutNextProcedureDataInput;
  upsert?: ProcedureUpsertWithoutNextProcedureInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ProcedureWhereUniqueInput;
}

export interface ItemSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ItemWhereInput;
  AND?: ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput;
  OR?: ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput;
  NOT?: ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput;
}

export interface StorageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  storageName?: String;
  storageName_not?: String;
  storageName_in?: String[] | String;
  storageName_not_in?: String[] | String;
  storageName_lt?: String;
  storageName_lte?: String;
  storageName_gt?: String;
  storageName_gte?: String;
  storageName_contains?: String;
  storageName_not_contains?: String;
  storageName_starts_with?: String;
  storageName_not_starts_with?: String;
  storageName_ends_with?: String;
  storageName_not_ends_with?: String;
  guardName?: UserWhereInput;
  items_every?: ItemWhereInput;
  items_some?: ItemWhereInput;
  items_none?: ItemWhereInput;
  AND?: StorageWhereInput[] | StorageWhereInput;
  OR?: StorageWhereInput[] | StorageWhereInput;
  NOT?: StorageWhereInput[] | StorageWhereInput;
}

export interface EntitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EntityWhereInput;
  AND?: EntitySubscriptionWhereInput[] | EntitySubscriptionWhereInput;
  OR?: EntitySubscriptionWhereInput[] | EntitySubscriptionWhereInput;
  NOT?: EntitySubscriptionWhereInput[] | EntitySubscriptionWhereInput;
}

export interface ProcedureUpdateWithoutPreviousProcedureDataInput {
  name?: String;
  startDate?: DateTimeInput;
  deadline?: DateTimeInput;
  progress?: Float;
  color?: String;
  nextProcedure?: ProcedureUpdateOneWithoutNextProcedureInput;
  users?: UserUpdateManyInput;
  documents?: DocumentUpdateManyInput;
  entities?: EntityUpdateManyInput;
}

export type BussinessTripWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProcedureUpdateOneWithoutPreviousProcedureInput {
  create?: ProcedureCreateWithoutPreviousProcedureInput;
  update?: ProcedureUpdateWithoutPreviousProcedureDataInput;
  upsert?: ProcedureUpsertWithoutPreviousProcedureInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ProcedureWhereUniqueInput;
}

export interface BussinessTripWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  applicant_every?: UserWhereInput;
  applicant_some?: UserWhereInput;
  applicant_none?: UserWhereInput;
  purpose?: String;
  purpose_not?: String;
  purpose_in?: String[] | String;
  purpose_not_in?: String[] | String;
  purpose_lt?: String;
  purpose_lte?: String;
  purpose_gt?: String;
  purpose_gte?: String;
  purpose_contains?: String;
  purpose_not_contains?: String;
  purpose_starts_with?: String;
  purpose_not_starts_with?: String;
  purpose_ends_with?: String;
  purpose_not_ends_with?: String;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  endDate?: DateTimeInput;
  endDate_not?: DateTimeInput;
  endDate_in?: DateTimeInput[] | DateTimeInput;
  endDate_not_in?: DateTimeInput[] | DateTimeInput;
  endDate_lt?: DateTimeInput;
  endDate_lte?: DateTimeInput;
  endDate_gt?: DateTimeInput;
  endDate_gte?: DateTimeInput;
  flightTicket?: String;
  flightTicket_not?: String;
  flightTicket_in?: String[] | String;
  flightTicket_not_in?: String[] | String;
  flightTicket_lt?: String;
  flightTicket_lte?: String;
  flightTicket_gt?: String;
  flightTicket_gte?: String;
  flightTicket_contains?: String;
  flightTicket_not_contains?: String;
  flightTicket_starts_with?: String;
  flightTicket_not_starts_with?: String;
  flightTicket_ends_with?: String;
  flightTicket_not_ends_with?: String;
  hotelRoom?: String;
  hotelRoom_not?: String;
  hotelRoom_in?: String[] | String;
  hotelRoom_not_in?: String[] | String;
  hotelRoom_lt?: String;
  hotelRoom_lte?: String;
  hotelRoom_gt?: String;
  hotelRoom_gte?: String;
  hotelRoom_contains?: String;
  hotelRoom_not_contains?: String;
  hotelRoom_starts_with?: String;
  hotelRoom_not_starts_with?: String;
  hotelRoom_ends_with?: String;
  hotelRoom_not_ends_with?: String;
  transport?: String;
  transport_not?: String;
  transport_in?: String[] | String;
  transport_not_in?: String[] | String;
  transport_lt?: String;
  transport_lte?: String;
  transport_gt?: String;
  transport_gte?: String;
  transport_contains?: String;
  transport_not_contains?: String;
  transport_starts_with?: String;
  transport_not_starts_with?: String;
  transport_ends_with?: String;
  transport_not_ends_with?: String;
  AND?: BussinessTripWhereInput[] | BussinessTripWhereInput;
  OR?: BussinessTripWhereInput[] | BussinessTripWhereInput;
  NOT?: BussinessTripWhereInput[] | BussinessTripWhereInput;
}

export interface ProcedureUpdateDataInput {
  name?: String;
  startDate?: DateTimeInput;
  deadline?: DateTimeInput;
  progress?: Float;
  color?: String;
  previousProcedure?: ProcedureUpdateOneWithoutPreviousProcedureInput;
  nextProcedure?: ProcedureUpdateOneWithoutNextProcedureInput;
  users?: UserUpdateManyInput;
  documents?: DocumentUpdateManyInput;
  entities?: EntityUpdateManyInput;
}

export interface BussinessTripSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BussinessTripWhereInput;
  AND?:
    | BussinessTripSubscriptionWhereInput[]
    | BussinessTripSubscriptionWhereInput;
  OR?:
    | BussinessTripSubscriptionWhereInput[]
    | BussinessTripSubscriptionWhereInput;
  NOT?:
    | BussinessTripSubscriptionWhereInput[]
    | BussinessTripSubscriptionWhereInput;
}

export interface ProcedureUpdateOneRequiredInput {
  create?: ProcedureCreateInput;
  update?: ProcedureUpdateDataInput;
  upsert?: ProcedureUpsertNestedInput;
  connect?: ProcedureWhereUniqueInput;
}

export interface ArticleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ArticleWhereInput;
  AND?: ArticleSubscriptionWhereInput[] | ArticleSubscriptionWhereInput;
  OR?: ArticleSubscriptionWhereInput[] | ArticleSubscriptionWhereInput;
  NOT?: ArticleSubscriptionWhereInput[] | ArticleSubscriptionWhereInput;
}

export type TransactionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AddressSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AddressWhereInput;
  AND?: AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput;
  OR?: AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput;
  NOT?: AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput;
}

export interface DocumentProcedureUpdateInput {
  from?: String;
  to?: String;
  procedureState?: ProcedureUpdateOneRequiredInput;
}

export interface VacationUpdateInput {
  applicant?: UserUpdateManyInput;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  routes?: Route;
  type?: VacationType;
  flightTicket?: String;
  hotelRoom?: String;
  transport?: String;
}

export interface EntityCreateManyInput {
  create?: EntityCreateInput[] | EntityCreateInput;
  connect?: EntityWhereUniqueInput[] | EntityWhereUniqueInput;
}

export type DocumentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TransactionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  place?: String;
  place_not?: String;
  place_in?: String[] | String;
  place_not_in?: String[] | String;
  place_lt?: String;
  place_lte?: String;
  place_gt?: String;
  place_gte?: String;
  place_contains?: String;
  place_not_contains?: String;
  place_starts_with?: String;
  place_not_starts_with?: String;
  place_ends_with?: String;
  place_not_ends_with?: String;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  applicant?: String;
  applicant_not?: String;
  applicant_in?: String[] | String;
  applicant_not_in?: String[] | String;
  applicant_lt?: String;
  applicant_lte?: String;
  applicant_gt?: String;
  applicant_gte?: String;
  applicant_contains?: String;
  applicant_not_contains?: String;
  applicant_starts_with?: String;
  applicant_not_starts_with?: String;
  applicant_ends_with?: String;
  applicant_not_ends_with?: String;
  item?: ItemWhereInput;
  quantity?: Int;
  quantity_not?: Int;
  quantity_in?: Int[] | Int;
  quantity_not_in?: Int[] | Int;
  quantity_lt?: Int;
  quantity_lte?: Int;
  quantity_gt?: Int;
  quantity_gte?: Int;
  total?: String;
  total_not?: String;
  total_in?: String[] | String;
  total_not_in?: String[] | String;
  total_lt?: String;
  total_lte?: String;
  total_gt?: String;
  total_gte?: String;
  total_contains?: String;
  total_not_contains?: String;
  total_starts_with?: String;
  total_not_starts_with?: String;
  total_ends_with?: String;
  total_not_ends_with?: String;
  type?: TransactionType;
  type_not?: TransactionType;
  type_in?: TransactionType[] | TransactionType;
  type_not_in?: TransactionType[] | TransactionType;
  AND?: TransactionWhereInput[] | TransactionWhereInput;
  OR?: TransactionWhereInput[] | TransactionWhereInput;
  NOT?: TransactionWhereInput[] | TransactionWhereInput;
}

export interface TransactionUpdatetagsInput {
  set?: String[] | String;
}

export interface DocumentCreateManyInput {
  create?: DocumentCreateInput[] | DocumentCreateInput;
  connect?: DocumentWhereUniqueInput[] | DocumentWhereUniqueInput;
}

export type DocumentProcedureWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProcedureCreateWithoutNextProcedureInput {
  name: String;
  startDate: DateTimeInput;
  deadline?: DateTimeInput;
  progress?: Float;
  color?: String;
  previousProcedure?: ProcedureCreateOneWithoutPreviousProcedureInput;
  users?: UserCreateManyInput;
  documents?: DocumentCreateManyInput;
  entities?: EntityCreateManyInput;
}

export interface TransactionUpdateInput {
  name?: String;
  place?: String;
  date?: DateTimeInput;
  description?: String;
  applicant?: String;
  item?: ItemUpdateOneInput;
  quantity?: Int;
  total?: String;
  type?: TransactionType;
  tags?: TransactionUpdatetagsInput;
}

export interface ProcedureCreateOneWithoutNextProcedureInput {
  create?: ProcedureCreateWithoutNextProcedureInput;
  connect?: ProcedureWhereUniqueInput;
}

export interface DocumentProcedureWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  from?: String;
  from_not?: String;
  from_in?: String[] | String;
  from_not_in?: String[] | String;
  from_lt?: String;
  from_lte?: String;
  from_gt?: String;
  from_gte?: String;
  from_contains?: String;
  from_not_contains?: String;
  from_starts_with?: String;
  from_not_starts_with?: String;
  from_ends_with?: String;
  from_not_ends_with?: String;
  to?: String;
  to_not?: String;
  to_in?: String[] | String;
  to_not_in?: String[] | String;
  to_lt?: String;
  to_lte?: String;
  to_gt?: String;
  to_gte?: String;
  to_contains?: String;
  to_not_contains?: String;
  to_starts_with?: String;
  to_not_starts_with?: String;
  to_ends_with?: String;
  to_not_ends_with?: String;
  procedureState?: ProcedureWhereInput;
  AND?: DocumentProcedureWhereInput[] | DocumentProcedureWhereInput;
  OR?: DocumentProcedureWhereInput[] | DocumentProcedureWhereInput;
  NOT?: DocumentProcedureWhereInput[] | DocumentProcedureWhereInput;
}

export interface ProcedureCreateWithoutPreviousProcedureInput {
  name: String;
  startDate: DateTimeInput;
  deadline?: DateTimeInput;
  progress?: Float;
  color?: String;
  nextProcedure?: ProcedureCreateOneWithoutNextProcedureInput;
  users?: UserCreateManyInput;
  documents?: DocumentCreateManyInput;
  entities?: EntityCreateManyInput;
}

export interface PartyMembershipWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  preEnrollDate?: DateTimeInput;
  preEnrollDate_not?: DateTimeInput;
  preEnrollDate_in?: DateTimeInput[] | DateTimeInput;
  preEnrollDate_not_in?: DateTimeInput[] | DateTimeInput;
  preEnrollDate_lt?: DateTimeInput;
  preEnrollDate_lte?: DateTimeInput;
  preEnrollDate_gt?: DateTimeInput;
  preEnrollDate_gte?: DateTimeInput;
  EnrollDate?: DateTimeInput;
  EnrollDate_not?: DateTimeInput;
  EnrollDate_in?: DateTimeInput[] | DateTimeInput;
  EnrollDate_not_in?: DateTimeInput[] | DateTimeInput;
  EnrollDate_lt?: DateTimeInput;
  EnrollDate_lte?: DateTimeInput;
  EnrollDate_gt?: DateTimeInput;
  EnrollDate_gte?: DateTimeInput;
  registerInDate?: DateTimeInput;
  registerInDate_not?: DateTimeInput;
  registerInDate_in?: DateTimeInput[] | DateTimeInput;
  registerInDate_not_in?: DateTimeInput[] | DateTimeInput;
  registerInDate_lt?: DateTimeInput;
  registerInDate_lte?: DateTimeInput;
  registerInDate_gt?: DateTimeInput;
  registerInDate_gte?: DateTimeInput;
  registerOutDate?: DateTimeInput;
  registerOutDate_not?: DateTimeInput;
  registerOutDate_in?: DateTimeInput[] | DateTimeInput;
  registerOutDate_not_in?: DateTimeInput[] | DateTimeInput;
  registerOutDate_lt?: DateTimeInput;
  registerOutDate_lte?: DateTimeInput;
  registerOutDate_gt?: DateTimeInput;
  registerOutDate_gte?: DateTimeInput;
  membershipState?: String;
  membershipState_not?: String;
  membershipState_in?: String[] | String;
  membershipState_not_in?: String[] | String;
  membershipState_lt?: String;
  membershipState_lte?: String;
  membershipState_gt?: String;
  membershipState_gte?: String;
  membershipState_contains?: String;
  membershipState_not_contains?: String;
  membershipState_starts_with?: String;
  membershipState_not_starts_with?: String;
  membershipState_ends_with?: String;
  membershipState_not_ends_with?: String;
  contact?: ContactWhereInput;
  belongToEntity?: PartyEntityWhereInput;
  AND?: PartyMembershipWhereInput[] | PartyMembershipWhereInput;
  OR?: PartyMembershipWhereInput[] | PartyMembershipWhereInput;
  NOT?: PartyMembershipWhereInput[] | PartyMembershipWhereInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ItemCreateOneInput {
  create?: ItemCreateInput;
  connect?: ItemWhereUniqueInput;
}

export interface ProcedureCreateOneWithoutPreviousProcedureInput {
  create?: ProcedureCreateWithoutPreviousProcedureInput;
  connect?: ProcedureWhereUniqueInput;
}

export type EntityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProcedureCreateInput {
  name: String;
  startDate: DateTimeInput;
  deadline?: DateTimeInput;
  progress?: Float;
  color?: String;
  previousProcedure?: ProcedureCreateOneWithoutPreviousProcedureInput;
  nextProcedure?: ProcedureCreateOneWithoutNextProcedureInput;
  users?: UserCreateManyInput;
  documents?: DocumentCreateManyInput;
  entities?: EntityCreateManyInput;
}

export interface ItemUpdateDataInput {
  name?: String;
  brand?: String;
  model?: String;
  productionDate?: DateTimeInput;
  overdueDate?: DateTimeInput;
  description?: String;
  price?: Float;
  mutationProcedure?: ItemProcedureUpdateOneRequiredInput;
}

export interface ProcedureCreateOneInput {
  create?: ProcedureCreateInput;
  connect?: ProcedureWhereUniqueInput;
}

export type EvaluationProcedureWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type VacationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface EvaluationProcedureWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  target?: UserWhereInput;
  positiveObservation?: String;
  positiveObservation_not?: String;
  positiveObservation_in?: String[] | String;
  positiveObservation_not_in?: String[] | String;
  positiveObservation_lt?: String;
  positiveObservation_lte?: String;
  positiveObservation_gt?: String;
  positiveObservation_gte?: String;
  positiveObservation_contains?: String;
  positiveObservation_not_contains?: String;
  positiveObservation_starts_with?: String;
  positiveObservation_not_starts_with?: String;
  positiveObservation_ends_with?: String;
  positiveObservation_not_ends_with?: String;
  negativeObservation?: String;
  negativeObservation_not?: String;
  negativeObservation_in?: String[] | String;
  negativeObservation_not_in?: String[] | String;
  negativeObservation_lt?: String;
  negativeObservation_lte?: String;
  negativeObservation_gt?: String;
  negativeObservation_gte?: String;
  negativeObservation_contains?: String;
  negativeObservation_not_contains?: String;
  negativeObservation_starts_with?: String;
  negativeObservation_not_starts_with?: String;
  negativeObservation_ends_with?: String;
  negativeObservation_not_ends_with?: String;
  expectation?: String;
  expectation_not?: String;
  expectation_in?: String[] | String;
  expectation_not_in?: String[] | String;
  expectation_lt?: String;
  expectation_lte?: String;
  expectation_gt?: String;
  expectation_gte?: String;
  expectation_contains?: String;
  expectation_not_contains?: String;
  expectation_starts_with?: String;
  expectation_not_starts_with?: String;
  expectation_ends_with?: String;
  expectation_not_ends_with?: String;
  performanceLevel?: String;
  performanceLevel_not?: String;
  performanceLevel_in?: String[] | String;
  performanceLevel_not_in?: String[] | String;
  performanceLevel_lt?: String;
  performanceLevel_lte?: String;
  performanceLevel_gt?: String;
  performanceLevel_gte?: String;
  performanceLevel_contains?: String;
  performanceLevel_not_contains?: String;
  performanceLevel_starts_with?: String;
  performanceLevel_not_starts_with?: String;
  performanceLevel_ends_with?: String;
  performanceLevel_not_ends_with?: String;
  proposal?: String;
  proposal_not?: String;
  proposal_in?: String[] | String;
  proposal_not_in?: String[] | String;
  proposal_lt?: String;
  proposal_lte?: String;
  proposal_gt?: String;
  proposal_gte?: String;
  proposal_contains?: String;
  proposal_not_contains?: String;
  proposal_starts_with?: String;
  proposal_not_starts_with?: String;
  proposal_ends_with?: String;
  proposal_not_ends_with?: String;
  directSuperior?: UserWhereInput;
  headOfInstitution?: UserWhereInput;
  procedureState?: ProcedureWhereInput;
  AND?: EvaluationProcedureWhereInput[] | EvaluationProcedureWhereInput;
  OR?: EvaluationProcedureWhereInput[] | EvaluationProcedureWhereInput;
  NOT?: EvaluationProcedureWhereInput[] | EvaluationProcedureWhereInput;
}

export interface DocumentProcedureCreateInput {
  from: String;
  to: String;
  procedureState: ProcedureCreateOneInput;
}

export interface StorageUpdateInput {
  storageName?: String;
  guardName?: UserUpdateOneRequiredInput;
  items?: ItemUpdateManyInput;
}

export interface UserUpsertWithoutDocumentsInput {
  update: UserUpdateWithoutDocumentsDataInput;
  create: UserCreateWithoutDocumentsInput;
}

export interface StorageCreateInput {
  storageName: String;
  guardName: UserCreateOneInput;
  items?: ItemCreateManyInput;
}

export interface UserUpdateWithoutDocumentsDataInput {
  protocolId?: String;
  name?: String;
  gender?: String;
  position?: String;
  etnia?: String;
  birthday?: DateTimeInput;
  academicBackground?: String;
  foreignLanguage?: String;
  politicalRole?: String;
  rank?: String;
  promotionDate?: DateTimeInput;
  outRole?: String;
  innerRole?: String;
  chargeOf?: String;
  sendingEntity?: String;
  arrivingDate?: DateTimeInput;
  leavingDate?: DateTimeInput;
  fromEntity?: String;
  memo?: String;
  contact?: ContactUpdateOneInput;
  partyMembership?: PartyMembershipUpdateOneInput;
}

export interface PromotionProcedureUpdateInput {
  previousRank?: String;
  currentRank?: String;
  promitionDate?: DateTimeInput;
  previousSalary?: String;
  currentSalary?: String;
  procedureState?: ProcedureUpdateOneRequiredInput;
}

export interface VacationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  applicant_every?: UserWhereInput;
  applicant_some?: UserWhereInput;
  applicant_none?: UserWhereInput;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  endDate?: DateTimeInput;
  endDate_not?: DateTimeInput;
  endDate_in?: DateTimeInput[] | DateTimeInput;
  endDate_not_in?: DateTimeInput[] | DateTimeInput;
  endDate_lt?: DateTimeInput;
  endDate_lte?: DateTimeInput;
  endDate_gt?: DateTimeInput;
  endDate_gte?: DateTimeInput;
  routes?: Route;
  routes_not?: Route;
  routes_in?: Route[] | Route;
  routes_not_in?: Route[] | Route;
  type?: VacationType;
  type_not?: VacationType;
  type_in?: VacationType[] | VacationType;
  type_not_in?: VacationType[] | VacationType;
  flightTicket?: String;
  flightTicket_not?: String;
  flightTicket_in?: String[] | String;
  flightTicket_not_in?: String[] | String;
  flightTicket_lt?: String;
  flightTicket_lte?: String;
  flightTicket_gt?: String;
  flightTicket_gte?: String;
  flightTicket_contains?: String;
  flightTicket_not_contains?: String;
  flightTicket_starts_with?: String;
  flightTicket_not_starts_with?: String;
  flightTicket_ends_with?: String;
  flightTicket_not_ends_with?: String;
  hotelRoom?: String;
  hotelRoom_not?: String;
  hotelRoom_in?: String[] | String;
  hotelRoom_not_in?: String[] | String;
  hotelRoom_lt?: String;
  hotelRoom_lte?: String;
  hotelRoom_gt?: String;
  hotelRoom_gte?: String;
  hotelRoom_contains?: String;
  hotelRoom_not_contains?: String;
  hotelRoom_starts_with?: String;
  hotelRoom_not_starts_with?: String;
  hotelRoom_ends_with?: String;
  hotelRoom_not_ends_with?: String;
  transport?: String;
  transport_not?: String;
  transport_in?: String[] | String;
  transport_not_in?: String[] | String;
  transport_lt?: String;
  transport_lte?: String;
  transport_gt?: String;
  transport_gte?: String;
  transport_contains?: String;
  transport_not_contains?: String;
  transport_starts_with?: String;
  transport_not_starts_with?: String;
  transport_ends_with?: String;
  transport_not_ends_with?: String;
  AND?: VacationWhereInput[] | VacationWhereInput;
  OR?: VacationWhereInput[] | VacationWhereInput;
  NOT?: VacationWhereInput[] | VacationWhereInput;
}

export interface ItemWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  brand?: String;
  brand_not?: String;
  brand_in?: String[] | String;
  brand_not_in?: String[] | String;
  brand_lt?: String;
  brand_lte?: String;
  brand_gt?: String;
  brand_gte?: String;
  brand_contains?: String;
  brand_not_contains?: String;
  brand_starts_with?: String;
  brand_not_starts_with?: String;
  brand_ends_with?: String;
  brand_not_ends_with?: String;
  model?: String;
  model_not?: String;
  model_in?: String[] | String;
  model_not_in?: String[] | String;
  model_lt?: String;
  model_lte?: String;
  model_gt?: String;
  model_gte?: String;
  model_contains?: String;
  model_not_contains?: String;
  model_starts_with?: String;
  model_not_starts_with?: String;
  model_ends_with?: String;
  model_not_ends_with?: String;
  productionDate?: DateTimeInput;
  productionDate_not?: DateTimeInput;
  productionDate_in?: DateTimeInput[] | DateTimeInput;
  productionDate_not_in?: DateTimeInput[] | DateTimeInput;
  productionDate_lt?: DateTimeInput;
  productionDate_lte?: DateTimeInput;
  productionDate_gt?: DateTimeInput;
  productionDate_gte?: DateTimeInput;
  overdueDate?: DateTimeInput;
  overdueDate_not?: DateTimeInput;
  overdueDate_in?: DateTimeInput[] | DateTimeInput;
  overdueDate_not_in?: DateTimeInput[] | DateTimeInput;
  overdueDate_lt?: DateTimeInput;
  overdueDate_lte?: DateTimeInput;
  overdueDate_gt?: DateTimeInput;
  overdueDate_gte?: DateTimeInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  price?: Float;
  price_not?: Float;
  price_in?: Float[] | Float;
  price_not_in?: Float[] | Float;
  price_lt?: Float;
  price_lte?: Float;
  price_gt?: Float;
  price_gte?: Float;
  mutationProcedure?: ItemProcedureWhereInput;
  AND?: ItemWhereInput[] | ItemWhereInput;
  OR?: ItemWhereInput[] | ItemWhereInput;
  NOT?: ItemWhereInput[] | ItemWhereInput;
}

export interface UserUpdateOneRequiredWithoutDocumentsInput {
  create?: UserCreateWithoutDocumentsInput;
  update?: UserUpdateWithoutDocumentsDataInput;
  upsert?: UserUpsertWithoutDocumentsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  protocolId?: String;
  protocolId_not?: String;
  protocolId_in?: String[] | String;
  protocolId_not_in?: String[] | String;
  protocolId_lt?: String;
  protocolId_lte?: String;
  protocolId_gt?: String;
  protocolId_gte?: String;
  protocolId_contains?: String;
  protocolId_not_contains?: String;
  protocolId_starts_with?: String;
  protocolId_not_starts_with?: String;
  protocolId_ends_with?: String;
  protocolId_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  gender?: String;
  gender_not?: String;
  gender_in?: String[] | String;
  gender_not_in?: String[] | String;
  gender_lt?: String;
  gender_lte?: String;
  gender_gt?: String;
  gender_gte?: String;
  gender_contains?: String;
  gender_not_contains?: String;
  gender_starts_with?: String;
  gender_not_starts_with?: String;
  gender_ends_with?: String;
  gender_not_ends_with?: String;
  position?: String;
  position_not?: String;
  position_in?: String[] | String;
  position_not_in?: String[] | String;
  position_lt?: String;
  position_lte?: String;
  position_gt?: String;
  position_gte?: String;
  position_contains?: String;
  position_not_contains?: String;
  position_starts_with?: String;
  position_not_starts_with?: String;
  position_ends_with?: String;
  position_not_ends_with?: String;
  etnia?: String;
  etnia_not?: String;
  etnia_in?: String[] | String;
  etnia_not_in?: String[] | String;
  etnia_lt?: String;
  etnia_lte?: String;
  etnia_gt?: String;
  etnia_gte?: String;
  etnia_contains?: String;
  etnia_not_contains?: String;
  etnia_starts_with?: String;
  etnia_not_starts_with?: String;
  etnia_ends_with?: String;
  etnia_not_ends_with?: String;
  birthday?: DateTimeInput;
  birthday_not?: DateTimeInput;
  birthday_in?: DateTimeInput[] | DateTimeInput;
  birthday_not_in?: DateTimeInput[] | DateTimeInput;
  birthday_lt?: DateTimeInput;
  birthday_lte?: DateTimeInput;
  birthday_gt?: DateTimeInput;
  birthday_gte?: DateTimeInput;
  academicBackground?: String;
  academicBackground_not?: String;
  academicBackground_in?: String[] | String;
  academicBackground_not_in?: String[] | String;
  academicBackground_lt?: String;
  academicBackground_lte?: String;
  academicBackground_gt?: String;
  academicBackground_gte?: String;
  academicBackground_contains?: String;
  academicBackground_not_contains?: String;
  academicBackground_starts_with?: String;
  academicBackground_not_starts_with?: String;
  academicBackground_ends_with?: String;
  academicBackground_not_ends_with?: String;
  foreignLanguage?: String;
  foreignLanguage_not?: String;
  foreignLanguage_in?: String[] | String;
  foreignLanguage_not_in?: String[] | String;
  foreignLanguage_lt?: String;
  foreignLanguage_lte?: String;
  foreignLanguage_gt?: String;
  foreignLanguage_gte?: String;
  foreignLanguage_contains?: String;
  foreignLanguage_not_contains?: String;
  foreignLanguage_starts_with?: String;
  foreignLanguage_not_starts_with?: String;
  foreignLanguage_ends_with?: String;
  foreignLanguage_not_ends_with?: String;
  politicalRole?: String;
  politicalRole_not?: String;
  politicalRole_in?: String[] | String;
  politicalRole_not_in?: String[] | String;
  politicalRole_lt?: String;
  politicalRole_lte?: String;
  politicalRole_gt?: String;
  politicalRole_gte?: String;
  politicalRole_contains?: String;
  politicalRole_not_contains?: String;
  politicalRole_starts_with?: String;
  politicalRole_not_starts_with?: String;
  politicalRole_ends_with?: String;
  politicalRole_not_ends_with?: String;
  rank?: String;
  rank_not?: String;
  rank_in?: String[] | String;
  rank_not_in?: String[] | String;
  rank_lt?: String;
  rank_lte?: String;
  rank_gt?: String;
  rank_gte?: String;
  rank_contains?: String;
  rank_not_contains?: String;
  rank_starts_with?: String;
  rank_not_starts_with?: String;
  rank_ends_with?: String;
  rank_not_ends_with?: String;
  promotionDate?: DateTimeInput;
  promotionDate_not?: DateTimeInput;
  promotionDate_in?: DateTimeInput[] | DateTimeInput;
  promotionDate_not_in?: DateTimeInput[] | DateTimeInput;
  promotionDate_lt?: DateTimeInput;
  promotionDate_lte?: DateTimeInput;
  promotionDate_gt?: DateTimeInput;
  promotionDate_gte?: DateTimeInput;
  outRole?: String;
  outRole_not?: String;
  outRole_in?: String[] | String;
  outRole_not_in?: String[] | String;
  outRole_lt?: String;
  outRole_lte?: String;
  outRole_gt?: String;
  outRole_gte?: String;
  outRole_contains?: String;
  outRole_not_contains?: String;
  outRole_starts_with?: String;
  outRole_not_starts_with?: String;
  outRole_ends_with?: String;
  outRole_not_ends_with?: String;
  innerRole?: String;
  innerRole_not?: String;
  innerRole_in?: String[] | String;
  innerRole_not_in?: String[] | String;
  innerRole_lt?: String;
  innerRole_lte?: String;
  innerRole_gt?: String;
  innerRole_gte?: String;
  innerRole_contains?: String;
  innerRole_not_contains?: String;
  innerRole_starts_with?: String;
  innerRole_not_starts_with?: String;
  innerRole_ends_with?: String;
  innerRole_not_ends_with?: String;
  chargeOf?: String;
  chargeOf_not?: String;
  chargeOf_in?: String[] | String;
  chargeOf_not_in?: String[] | String;
  chargeOf_lt?: String;
  chargeOf_lte?: String;
  chargeOf_gt?: String;
  chargeOf_gte?: String;
  chargeOf_contains?: String;
  chargeOf_not_contains?: String;
  chargeOf_starts_with?: String;
  chargeOf_not_starts_with?: String;
  chargeOf_ends_with?: String;
  chargeOf_not_ends_with?: String;
  sendingEntity?: String;
  sendingEntity_not?: String;
  sendingEntity_in?: String[] | String;
  sendingEntity_not_in?: String[] | String;
  sendingEntity_lt?: String;
  sendingEntity_lte?: String;
  sendingEntity_gt?: String;
  sendingEntity_gte?: String;
  sendingEntity_contains?: String;
  sendingEntity_not_contains?: String;
  sendingEntity_starts_with?: String;
  sendingEntity_not_starts_with?: String;
  sendingEntity_ends_with?: String;
  sendingEntity_not_ends_with?: String;
  arrivingDate?: DateTimeInput;
  arrivingDate_not?: DateTimeInput;
  arrivingDate_in?: DateTimeInput[] | DateTimeInput;
  arrivingDate_not_in?: DateTimeInput[] | DateTimeInput;
  arrivingDate_lt?: DateTimeInput;
  arrivingDate_lte?: DateTimeInput;
  arrivingDate_gt?: DateTimeInput;
  arrivingDate_gte?: DateTimeInput;
  leavingDate?: DateTimeInput;
  leavingDate_not?: DateTimeInput;
  leavingDate_in?: DateTimeInput[] | DateTimeInput;
  leavingDate_not_in?: DateTimeInput[] | DateTimeInput;
  leavingDate_lt?: DateTimeInput;
  leavingDate_lte?: DateTimeInput;
  leavingDate_gt?: DateTimeInput;
  leavingDate_gte?: DateTimeInput;
  fromEntity?: String;
  fromEntity_not?: String;
  fromEntity_in?: String[] | String;
  fromEntity_not_in?: String[] | String;
  fromEntity_lt?: String;
  fromEntity_lte?: String;
  fromEntity_gt?: String;
  fromEntity_gte?: String;
  fromEntity_contains?: String;
  fromEntity_not_contains?: String;
  fromEntity_starts_with?: String;
  fromEntity_not_starts_with?: String;
  fromEntity_ends_with?: String;
  fromEntity_not_ends_with?: String;
  memo?: String;
  memo_not?: String;
  memo_in?: String[] | String;
  memo_not_in?: String[] | String;
  memo_lt?: String;
  memo_lte?: String;
  memo_gt?: String;
  memo_gte?: String;
  memo_contains?: String;
  memo_not_contains?: String;
  memo_starts_with?: String;
  memo_not_starts_with?: String;
  memo_ends_with?: String;
  memo_not_ends_with?: String;
  contact?: ContactWhereInput;
  partyMembership?: PartyMembershipWhereInput;
  documents_every?: DocumentWhereInput;
  documents_some?: DocumentWhereInput;
  documents_none?: DocumentWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface DocumentUpdateInput {
  type?: String;
  mark?: String;
  classification?: String;
  startDate?: DateTimeInput;
  title?: String;
  text?: String;
  fromEntity?: EntityUpdateOneRequiredInput;
  sendingEntity?: EntityUpdateOneRequiredInput;
  toEntity?: EntityUpdateOneRequiredInput;
  copyEntity?: EntityUpdateOneInput;
  attachment?: String;
  tags?: String;
  author?: UserUpdateOneRequiredWithoutDocumentsInput;
}

export interface PersonUpdateInput {
  name?: String;
  gender?: String;
  birthday?: DateTimeInput;
}

export interface UserCreateWithoutDocumentsInput {
  protocolId?: String;
  name: String;
  gender: String;
  position?: String;
  etnia: String;
  birthday: DateTimeInput;
  academicBackground?: String;
  foreignLanguage?: String;
  politicalRole?: String;
  rank?: String;
  promotionDate?: DateTimeInput;
  outRole?: String;
  innerRole?: String;
  chargeOf?: String;
  sendingEntity?: String;
  arrivingDate?: DateTimeInput;
  leavingDate?: DateTimeInput;
  fromEntity?: String;
  memo?: String;
  contact?: ContactCreateOneInput;
  partyMembership?: PartyMembershipCreateOneInput;
}

export type ItemProcedureWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserCreateOneWithoutDocumentsInput {
  create?: UserCreateWithoutDocumentsInput;
  connect?: UserWhereUniqueInput;
}

export interface PartyMembershipUpdateInput {
  name?: String;
  preEnrollDate?: DateTimeInput;
  EnrollDate?: DateTimeInput;
  registerInDate?: DateTimeInput;
  registerOutDate?: DateTimeInput;
  membershipState?: String;
  contact?: ContactUpdateOneInput;
  belongToEntity?: PartyEntityUpdateOneRequiredInput;
}

export interface LocationUpdateInput {
  latitude?: Float;
  longitude?: Float;
}

export interface AddressWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  street?: String;
  street_not?: String;
  street_in?: String[] | String;
  street_not_in?: String[] | String;
  street_lt?: String;
  street_lte?: String;
  street_gt?: String;
  street_gte?: String;
  street_contains?: String;
  street_not_contains?: String;
  street_starts_with?: String;
  street_not_starts_with?: String;
  street_ends_with?: String;
  street_not_ends_with?: String;
  suite?: String;
  suite_not?: String;
  suite_in?: String[] | String;
  suite_not_in?: String[] | String;
  suite_lt?: String;
  suite_lte?: String;
  suite_gt?: String;
  suite_gte?: String;
  suite_contains?: String;
  suite_not_contains?: String;
  suite_starts_with?: String;
  suite_not_starts_with?: String;
  suite_ends_with?: String;
  suite_not_ends_with?: String;
  area?: String;
  area_not?: String;
  area_in?: String[] | String;
  area_not_in?: String[] | String;
  area_lt?: String;
  area_lte?: String;
  area_gt?: String;
  area_gte?: String;
  area_contains?: String;
  area_not_contains?: String;
  area_starts_with?: String;
  area_not_starts_with?: String;
  area_ends_with?: String;
  area_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  state?: String;
  state_not?: String;
  state_in?: String[] | String;
  state_not_in?: String[] | String;
  state_lt?: String;
  state_lte?: String;
  state_gt?: String;
  state_gte?: String;
  state_contains?: String;
  state_not_contains?: String;
  state_starts_with?: String;
  state_not_starts_with?: String;
  state_ends_with?: String;
  state_not_ends_with?: String;
  country?: String;
  country_not?: String;
  country_in?: String[] | String;
  country_not_in?: String[] | String;
  country_lt?: String;
  country_lte?: String;
  country_gt?: String;
  country_gte?: String;
  country_contains?: String;
  country_not_contains?: String;
  country_starts_with?: String;
  country_not_starts_with?: String;
  country_ends_with?: String;
  country_not_ends_with?: String;
  zipcode?: String;
  zipcode_not?: String;
  zipcode_in?: String[] | String;
  zipcode_not_in?: String[] | String;
  zipcode_lt?: String;
  zipcode_lte?: String;
  zipcode_gt?: String;
  zipcode_gte?: String;
  zipcode_contains?: String;
  zipcode_not_contains?: String;
  zipcode_starts_with?: String;
  zipcode_not_starts_with?: String;
  zipcode_ends_with?: String;
  zipcode_not_ends_with?: String;
  geo?: LocationWhereInput;
  AND?: AddressWhereInput[] | AddressWhereInput;
  OR?: AddressWhereInput[] | AddressWhereInput;
  NOT?: AddressWhereInput[] | AddressWhereInput;
}

export interface ActivityCreateInput {
  address: AddressCreateOneInput;
  occurrenceDate: DateTimeInput;
  content: String;
  applicant: UserCreateOneInput;
  participants?: UserCreateManyInput;
  currentDate: DateTimeInput;
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  reporter?: UserCreateManyInput;
  reportDate: DateTimeInput;
  reportContent: String;
  instructor?: UserCreateManyInput;
  instructionDate: DateTimeInput;
  instruction: String;
  priority: PriorityLevel;
}

export interface ItemProcedureUpsertNestedInput {
  update: ItemProcedureUpdateDataInput;
  create: ItemProcedureCreateInput;
}

export interface AddressCreateOneInput {
  create?: AddressCreateInput;
  connect?: AddressWhereUniqueInput;
}

export type PartyEntityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AddressCreateInput {
  street: String;
  suite: String;
  area: String;
  city: String;
  state: String;
  country: String;
  zipcode?: String;
  geo?: LocationCreateOneInput;
}

export interface ItemProcedureUpdateOneRequiredInput {
  create?: ItemProcedureCreateInput;
  update?: ItemProcedureUpdateDataInput;
  upsert?: ItemProcedureUpsertNestedInput;
  connect?: ItemProcedureWhereUniqueInput;
}

export interface LocationCreateOneInput {
  create?: LocationCreateInput;
  connect?: LocationWhereUniqueInput;
}

export interface ItemProcedureCreateInput {
  previousPlace: String;
  currentPlace: String;
  devaluation: String;
  procedureState: ProcedureCreateOneInput;
}

export interface LocationCreateInput {
  latitude: Float;
  longitude: Float;
}

export interface DocumentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  mark?: String;
  mark_not?: String;
  mark_in?: String[] | String;
  mark_not_in?: String[] | String;
  mark_lt?: String;
  mark_lte?: String;
  mark_gt?: String;
  mark_gte?: String;
  mark_contains?: String;
  mark_not_contains?: String;
  mark_starts_with?: String;
  mark_not_starts_with?: String;
  mark_ends_with?: String;
  mark_not_ends_with?: String;
  classification?: String;
  classification_not?: String;
  classification_in?: String[] | String;
  classification_not_in?: String[] | String;
  classification_lt?: String;
  classification_lte?: String;
  classification_gt?: String;
  classification_gte?: String;
  classification_contains?: String;
  classification_not_contains?: String;
  classification_starts_with?: String;
  classification_not_starts_with?: String;
  classification_ends_with?: String;
  classification_not_ends_with?: String;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  fromEntity?: EntityWhereInput;
  sendingEntity?: EntityWhereInput;
  toEntity?: EntityWhereInput;
  copyEntity?: EntityWhereInput;
  attachment?: String;
  attachment_not?: String;
  attachment_in?: String[] | String;
  attachment_not_in?: String[] | String;
  attachment_lt?: String;
  attachment_lte?: String;
  attachment_gt?: String;
  attachment_gte?: String;
  attachment_contains?: String;
  attachment_not_contains?: String;
  attachment_starts_with?: String;
  attachment_not_starts_with?: String;
  attachment_ends_with?: String;
  attachment_not_ends_with?: String;
  tags?: String;
  tags_not?: String;
  tags_in?: String[] | String;
  tags_not_in?: String[] | String;
  tags_lt?: String;
  tags_lte?: String;
  tags_gt?: String;
  tags_gte?: String;
  tags_contains?: String;
  tags_not_contains?: String;
  tags_starts_with?: String;
  tags_not_starts_with?: String;
  tags_ends_with?: String;
  tags_not_ends_with?: String;
  author?: UserWhereInput;
  AND?: DocumentWhereInput[] | DocumentWhereInput;
  OR?: DocumentWhereInput[] | DocumentWhereInput;
  NOT?: DocumentWhereInput[] | DocumentWhereInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface ItemCreateInput {
  name: String;
  brand: String;
  model: String;
  productionDate?: DateTimeInput;
  overdueDate?: DateTimeInput;
  description?: String;
  price: Float;
  mutationProcedure: ItemProcedureCreateOneInput;
}

export interface UserCreateInput {
  protocolId?: String;
  name: String;
  gender: String;
  position?: String;
  etnia: String;
  birthday: DateTimeInput;
  academicBackground?: String;
  foreignLanguage?: String;
  politicalRole?: String;
  rank?: String;
  promotionDate?: DateTimeInput;
  outRole?: String;
  innerRole?: String;
  chargeOf?: String;
  sendingEntity?: String;
  arrivingDate?: DateTimeInput;
  leavingDate?: DateTimeInput;
  fromEntity?: String;
  memo?: String;
  contact?: ContactCreateOneInput;
  partyMembership?: PartyMembershipCreateOneInput;
  documents?: DocumentCreateManyWithoutAuthorInput;
}

export type PersonWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ContactCreateOneInput {
  create?: ContactCreateInput;
  connect?: ContactWhereUniqueInput;
}

export interface PersonWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  gender?: String;
  gender_not?: String;
  gender_in?: String[] | String;
  gender_not_in?: String[] | String;
  gender_lt?: String;
  gender_lte?: String;
  gender_gt?: String;
  gender_gte?: String;
  gender_contains?: String;
  gender_not_contains?: String;
  gender_starts_with?: String;
  gender_not_starts_with?: String;
  gender_ends_with?: String;
  gender_not_ends_with?: String;
  birthday?: DateTimeInput;
  birthday_not?: DateTimeInput;
  birthday_in?: DateTimeInput[] | DateTimeInput;
  birthday_not_in?: DateTimeInput[] | DateTimeInput;
  birthday_lt?: DateTimeInput;
  birthday_lte?: DateTimeInput;
  birthday_gt?: DateTimeInput;
  birthday_gte?: DateTimeInput;
  AND?: PersonWhereInput[] | PersonWhereInput;
  OR?: PersonWhereInput[] | PersonWhereInput;
  NOT?: PersonWhereInput[] | PersonWhereInput;
}

export interface ContactCreateInput {
  homePhone: String;
  officePhone: String;
  cellPhone: String;
  email: String;
  wechat?: String;
  whatsapp?: String;
  github?: String;
  twitter?: String;
  instagram?: String;
  homepage?: String;
  avatar?: String;
}

export interface EntityUpdateInput {
  name?: String;
  fullName?: String;
  abbr?: String;
  address?: AddressUpdateOneRequiredInput;
  avatar?: String;
}

export interface PartyMembershipCreateOneInput {
  create?: PartyMembershipCreateInput;
  connect?: PartyMembershipWhereUniqueInput;
}

export interface ProcedureUpsertWithoutPreviousProcedureInput {
  update: ProcedureUpdateWithoutPreviousProcedureDataInput;
  create: ProcedureCreateWithoutPreviousProcedureInput;
}

export interface PartyMembershipCreateInput {
  name: String;
  preEnrollDate: DateTimeInput;
  EnrollDate: DateTimeInput;
  registerInDate: DateTimeInput;
  registerOutDate: DateTimeInput;
  membershipState: String;
  contact?: ContactCreateOneInput;
  belongToEntity: PartyEntityCreateOneInput;
}

export interface ProcedureUpsertWithoutNextProcedureInput {
  update: ProcedureUpdateWithoutNextProcedureDataInput;
  create: ProcedureCreateWithoutNextProcedureInput;
}

export interface PartyEntityCreateOneInput {
  create?: PartyEntityCreateInput;
  connect?: PartyEntityWhereUniqueInput;
}

export interface VacationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VacationWhereInput;
  AND?: VacationSubscriptionWhereInput[] | VacationSubscriptionWhereInput;
  OR?: VacationSubscriptionWhereInput[] | VacationSubscriptionWhereInput;
  NOT?: VacationSubscriptionWhereInput[] | VacationSubscriptionWhereInput;
}

export interface PartyEntityCreateInput {
  name: String;
  fullName: String;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
}

export interface StorageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StorageWhereInput;
  AND?: StorageSubscriptionWhereInput[] | StorageSubscriptionWhereInput;
  OR?: StorageSubscriptionWhereInput[] | StorageSubscriptionWhereInput;
  NOT?: StorageSubscriptionWhereInput[] | StorageSubscriptionWhereInput;
}

export interface DocumentCreateManyWithoutAuthorInput {
  create?:
    | DocumentCreateWithoutAuthorInput[]
    | DocumentCreateWithoutAuthorInput;
  connect?: DocumentWhereUniqueInput[] | DocumentWhereUniqueInput;
}

export interface PersonSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PersonWhereInput;
  AND?: PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput;
  OR?: PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput;
  NOT?: PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput;
}

export interface DocumentCreateWithoutAuthorInput {
  type?: String;
  mark?: String;
  classification?: String;
  startDate: DateTimeInput;
  title: String;
  text: String;
  fromEntity: EntityCreateOneInput;
  sendingEntity: EntityCreateOneInput;
  toEntity: EntityCreateOneInput;
  copyEntity?: EntityCreateOneInput;
  attachment?: String;
  tags?: String;
}

export interface PartyEntitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PartyEntityWhereInput;
  AND?: PartyEntitySubscriptionWhereInput[] | PartyEntitySubscriptionWhereInput;
  OR?: PartyEntitySubscriptionWhereInput[] | PartyEntitySubscriptionWhereInput;
  NOT?: PartyEntitySubscriptionWhereInput[] | PartyEntitySubscriptionWhereInput;
}

export interface EntityCreateOneInput {
  create?: EntityCreateInput;
  connect?: EntityWhereUniqueInput;
}

export interface BanqueteWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  applicant?: String;
  applicant_not?: String;
  applicant_in?: String[] | String;
  applicant_not_in?: String[] | String;
  applicant_lt?: String;
  applicant_lte?: String;
  applicant_gt?: String;
  applicant_gte?: String;
  applicant_contains?: String;
  applicant_not_contains?: String;
  applicant_starts_with?: String;
  applicant_not_starts_with?: String;
  applicant_ends_with?: String;
  applicant_not_ends_with?: String;
  purpose?: String;
  purpose_not?: String;
  purpose_in?: String[] | String;
  purpose_not_in?: String[] | String;
  purpose_lt?: String;
  purpose_lte?: String;
  purpose_gt?: String;
  purpose_gte?: String;
  purpose_contains?: String;
  purpose_not_contains?: String;
  purpose_starts_with?: String;
  purpose_not_starts_with?: String;
  purpose_ends_with?: String;
  purpose_not_ends_with?: String;
  offerer?: UserWhereInput;
  authorizer?: UserWhereInput;
  companions_every?: UserWhereInput;
  companions_some?: UserWhereInput;
  companions_none?: UserWhereInput;
  guests_every?: UserWhereInput;
  guests_some?: UserWhereInput;
  guests_none?: UserWhereInput;
  place?: EntityWhereInput;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  total?: String;
  total_not?: String;
  total_in?: String[] | String;
  total_not_in?: String[] | String;
  total_lt?: String;
  total_lte?: String;
  total_gt?: String;
  total_gte?: String;
  total_contains?: String;
  total_not_contains?: String;
  total_starts_with?: String;
  total_not_starts_with?: String;
  total_ends_with?: String;
  total_not_ends_with?: String;
  AND?: BanqueteWhereInput[] | BanqueteWhereInput;
  OR?: BanqueteWhereInput[] | BanqueteWhereInput;
  NOT?: BanqueteWhereInput[] | BanqueteWhereInput;
}

export interface EntityCreateInput {
  name: String;
  fullName: String;
  abbr: String;
  address: AddressCreateOneInput;
  avatar?: String;
}

export interface DocumentProcedureSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DocumentProcedureWhereInput;
  AND?:
    | DocumentProcedureSubscriptionWhereInput[]
    | DocumentProcedureSubscriptionWhereInput;
  OR?:
    | DocumentProcedureSubscriptionWhereInput[]
    | DocumentProcedureSubscriptionWhereInput;
  NOT?:
    | DocumentProcedureSubscriptionWhereInput[]
    | DocumentProcedureSubscriptionWhereInput;
}

export interface DocumentCreateInput {
  type?: String;
  mark?: String;
  classification?: String;
  startDate: DateTimeInput;
  title: String;
  text: String;
  fromEntity: EntityCreateOneInput;
  sendingEntity: EntityCreateOneInput;
  toEntity: EntityCreateOneInput;
  copyEntity?: EntityCreateOneInput;
  attachment?: String;
  tags?: String;
  author: UserCreateOneWithoutDocumentsInput;
}

export interface ContactSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ContactWhereInput;
  AND?: ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput;
  OR?: ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput;
  NOT?: ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput;
}

export interface ActivityUpdateInput {
  address?: AddressUpdateOneRequiredInput;
  occurrenceDate?: DateTimeInput;
  content?: String;
  applicant?: UserUpdateOneRequiredInput;
  participants?: UserUpdateManyInput;
  currentDate?: DateTimeInput;
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  reporter?: UserUpdateManyInput;
  reportDate?: DateTimeInput;
  reportContent?: String;
  instructor?: UserUpdateManyInput;
  instructionDate?: DateTimeInput;
  instruction?: String;
  priority?: PriorityLevel;
}

export type ContactWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AddressUpdateOneRequiredInput {
  create?: AddressCreateInput;
  update?: AddressUpdateDataInput;
  upsert?: AddressUpsertNestedInput;
  connect?: AddressWhereUniqueInput;
}

export interface VacationCreateInput {
  applicant?: UserCreateManyInput;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
  routes: Route;
  type: VacationType;
  flightTicket?: String;
  hotelRoom?: String;
  transport?: String;
}

export interface AddressUpdateDataInput {
  street?: String;
  suite?: String;
  area?: String;
  city?: String;
  state?: String;
  country?: String;
  zipcode?: String;
  geo?: LocationUpdateOneInput;
}

export interface ItemUpsertNestedInput {
  update: ItemUpdateDataInput;
  create: ItemCreateInput;
}

export interface LocationUpdateOneInput {
  create?: LocationCreateInput;
  update?: LocationUpdateDataInput;
  upsert?: LocationUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: LocationWhereUniqueInput;
}

export interface PartyEntityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  fullName?: String;
  fullName_not?: String;
  fullName_in?: String[] | String;
  fullName_not_in?: String[] | String;
  fullName_lt?: String;
  fullName_lte?: String;
  fullName_gt?: String;
  fullName_gte?: String;
  fullName_contains?: String;
  fullName_not_contains?: String;
  fullName_starts_with?: String;
  fullName_not_starts_with?: String;
  fullName_ends_with?: String;
  fullName_not_ends_with?: String;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  endDate?: DateTimeInput;
  endDate_not?: DateTimeInput;
  endDate_in?: DateTimeInput[] | DateTimeInput;
  endDate_not_in?: DateTimeInput[] | DateTimeInput;
  endDate_lt?: DateTimeInput;
  endDate_lte?: DateTimeInput;
  endDate_gt?: DateTimeInput;
  endDate_gte?: DateTimeInput;
  AND?: PartyEntityWhereInput[] | PartyEntityWhereInput;
  OR?: PartyEntityWhereInput[] | PartyEntityWhereInput;
  NOT?: PartyEntityWhereInput[] | PartyEntityWhereInput;
}

export interface LocationUpdateDataInput {
  latitude?: Float;
  longitude?: Float;
}

export interface TransactionCreatetagsInput {
  set?: String[] | String;
}

export interface LocationUpsertNestedInput {
  update: LocationUpdateDataInput;
  create: LocationCreateInput;
}

export interface ItemUpsertWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateDataInput;
  create: ItemCreateInput;
}

export interface AddressUpsertNestedInput {
  update: AddressUpdateDataInput;
  create: AddressCreateInput;
}

export interface ItemUpdateManyInput {
  create?: ItemCreateInput[] | ItemCreateInput;
  update?:
    | ItemUpdateWithWhereUniqueNestedInput[]
    | ItemUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ItemUpsertWithWhereUniqueNestedInput[]
    | ItemUpsertWithWhereUniqueNestedInput;
  delete?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  connect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  disconnect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface ItemCreateManyInput {
  create?: ItemCreateInput[] | ItemCreateInput;
  connect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
}

export interface UserUpdateDataInput {
  protocolId?: String;
  name?: String;
  gender?: String;
  position?: String;
  etnia?: String;
  birthday?: DateTimeInput;
  academicBackground?: String;
  foreignLanguage?: String;
  politicalRole?: String;
  rank?: String;
  promotionDate?: DateTimeInput;
  outRole?: String;
  innerRole?: String;
  chargeOf?: String;
  sendingEntity?: String;
  arrivingDate?: DateTimeInput;
  leavingDate?: DateTimeInput;
  fromEntity?: String;
  memo?: String;
  contact?: ContactUpdateOneInput;
  partyMembership?: PartyMembershipUpdateOneInput;
  documents?: DocumentUpdateManyWithoutAuthorInput;
}

export interface PromotionProcedureCreateInput {
  previousRank: String;
  currentRank: String;
  promitionDate: DateTimeInput;
  previousSalary: String;
  currentSalary: String;
  procedureState: ProcedureCreateOneInput;
}

export interface ContactUpdateOneInput {
  create?: ContactCreateInput;
  update?: ContactUpdateDataInput;
  upsert?: ContactUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ContactWhereUniqueInput;
}

export interface ProcedureUpdateInput {
  name?: String;
  startDate?: DateTimeInput;
  deadline?: DateTimeInput;
  progress?: Float;
  color?: String;
  previousProcedure?: ProcedureUpdateOneWithoutPreviousProcedureInput;
  nextProcedure?: ProcedureUpdateOneWithoutNextProcedureInput;
  users?: UserUpdateManyInput;
  documents?: DocumentUpdateManyInput;
  entities?: EntityUpdateManyInput;
}

export interface ContactUpdateDataInput {
  homePhone?: String;
  officePhone?: String;
  cellPhone?: String;
  email?: String;
  wechat?: String;
  whatsapp?: String;
  github?: String;
  twitter?: String;
  instagram?: String;
  homepage?: String;
  avatar?: String;
}

export interface LocationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  latitude?: Float;
  latitude_not?: Float;
  latitude_in?: Float[] | Float;
  latitude_not_in?: Float[] | Float;
  latitude_lt?: Float;
  latitude_lte?: Float;
  latitude_gt?: Float;
  latitude_gte?: Float;
  longitude?: Float;
  longitude_not?: Float;
  longitude_in?: Float[] | Float;
  longitude_not_in?: Float[] | Float;
  longitude_lt?: Float;
  longitude_lte?: Float;
  longitude_gt?: Float;
  longitude_gte?: Float;
  AND?: LocationWhereInput[] | LocationWhereInput;
  OR?: LocationWhereInput[] | LocationWhereInput;
  NOT?: LocationWhereInput[] | LocationWhereInput;
}

export interface ContactUpsertNestedInput {
  update: ContactUpdateDataInput;
  create: ContactCreateInput;
}

export type LocationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PartyMembershipUpdateOneInput {
  create?: PartyMembershipCreateInput;
  update?: PartyMembershipUpdateDataInput;
  upsert?: PartyMembershipUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PartyMembershipWhereUniqueInput;
}

export interface ItemProcedureUpdateDataInput {
  previousPlace?: String;
  currentPlace?: String;
  devaluation?: String;
  procedureState?: ProcedureUpdateOneRequiredInput;
}

export interface PartyMembershipUpdateDataInput {
  name?: String;
  preEnrollDate?: DateTimeInput;
  EnrollDate?: DateTimeInput;
  registerInDate?: DateTimeInput;
  registerOutDate?: DateTimeInput;
  membershipState?: String;
  contact?: ContactUpdateOneInput;
  belongToEntity?: PartyEntityUpdateOneRequiredInput;
}

export interface ItemUpdateInput {
  name?: String;
  brand?: String;
  model?: String;
  productionDate?: DateTimeInput;
  overdueDate?: DateTimeInput;
  description?: String;
  price?: Float;
  mutationProcedure?: ItemProcedureUpdateOneRequiredInput;
}

export interface ContactUpdateInput {
  homePhone?: String;
  officePhone?: String;
  cellPhone?: String;
  email?: String;
  wechat?: String;
  whatsapp?: String;
  github?: String;
  twitter?: String;
  instagram?: String;
  homepage?: String;
  avatar?: String;
}

export interface ItemProcedureCreateOneInput {
  create?: ItemProcedureCreateInput;
  connect?: ItemProcedureWhereUniqueInput;
}

export interface PartyEntityUpdateDataInput {
  name?: String;
  fullName?: String;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
}

export interface EvaluationProcedureUpdateInput {
  target?: UserUpdateOneRequiredInput;
  positiveObservation?: String;
  negativeObservation?: String;
  expectation?: String;
  performanceLevel?: String;
  proposal?: String;
  directSuperior?: UserUpdateOneRequiredInput;
  headOfInstitution?: UserUpdateOneInput;
  procedureState?: ProcedureUpdateOneRequiredInput;
}

export interface PartyEntityUpsertNestedInput {
  update: PartyEntityUpdateDataInput;
  create: PartyEntityCreateInput;
}

export interface ProcedureUpsertNestedInput {
  update: ProcedureUpdateDataInput;
  create: ProcedureCreateInput;
}

export interface PartyMembershipUpsertNestedInput {
  update: PartyMembershipUpdateDataInput;
  create: PartyMembershipCreateInput;
}

export interface EntityUpsertWithWhereUniqueNestedInput {
  where: EntityWhereUniqueInput;
  update: EntityUpdateDataInput;
  create: EntityCreateInput;
}

export interface DocumentUpdateManyWithoutAuthorInput {
  create?:
    | DocumentCreateWithoutAuthorInput[]
    | DocumentCreateWithoutAuthorInput;
  delete?: DocumentWhereUniqueInput[] | DocumentWhereUniqueInput;
  connect?: DocumentWhereUniqueInput[] | DocumentWhereUniqueInput;
  disconnect?: DocumentWhereUniqueInput[] | DocumentWhereUniqueInput;
  update?:
    | DocumentUpdateWithWhereUniqueWithoutAuthorInput[]
    | DocumentUpdateWithWhereUniqueWithoutAuthorInput;
  upsert?:
    | DocumentUpsertWithWhereUniqueWithoutAuthorInput[]
    | DocumentUpsertWithWhereUniqueWithoutAuthorInput;
}

export type ArticleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DocumentUpdateWithWhereUniqueWithoutAuthorInput {
  where: DocumentWhereUniqueInput;
  data: DocumentUpdateWithoutAuthorDataInput;
}

export type BanqueteWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DocumentUpdateWithoutAuthorDataInput {
  type?: String;
  mark?: String;
  classification?: String;
  startDate?: DateTimeInput;
  title?: String;
  text?: String;
  fromEntity?: EntityUpdateOneRequiredInput;
  sendingEntity?: EntityUpdateOneRequiredInput;
  toEntity?: EntityUpdateOneRequiredInput;
  copyEntity?: EntityUpdateOneInput;
  attachment?: String;
  tags?: String;
}

export interface DocumentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DocumentWhereInput;
  AND?: DocumentSubscriptionWhereInput[] | DocumentSubscriptionWhereInput;
  OR?: DocumentSubscriptionWhereInput[] | DocumentSubscriptionWhereInput;
  NOT?: DocumentSubscriptionWhereInput[] | DocumentSubscriptionWhereInput;
}

export interface EntityUpdateOneRequiredInput {
  create?: EntityCreateInput;
  update?: EntityUpdateDataInput;
  upsert?: EntityUpsertNestedInput;
  connect?: EntityWhereUniqueInput;
}

export interface ActivitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ActivityWhereInput;
  AND?: ActivitySubscriptionWhereInput[] | ActivitySubscriptionWhereInput;
  OR?: ActivitySubscriptionWhereInput[] | ActivitySubscriptionWhereInput;
  NOT?: ActivitySubscriptionWhereInput[] | ActivitySubscriptionWhereInput;
}

export interface EntityUpdateDataInput {
  name?: String;
  fullName?: String;
  abbr?: String;
  address?: AddressUpdateOneRequiredInput;
  avatar?: String;
}

export interface ItemUpdateOneInput {
  create?: ItemCreateInput;
  update?: ItemUpdateDataInput;
  upsert?: ItemUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ItemWhereUniqueInput;
}

export interface EntityUpsertNestedInput {
  update: EntityUpdateDataInput;
  create: EntityCreateInput;
}

export interface TransactionCreateInput {
  name: String;
  place?: String;
  date: DateTimeInput;
  description?: String;
  applicant: String;
  item?: ItemCreateOneInput;
  quantity?: Int;
  total: String;
  type: TransactionType;
  tags?: TransactionCreatetagsInput;
}

export interface EntityUpdateOneInput {
  create?: EntityCreateInput;
  update?: EntityUpdateDataInput;
  upsert?: EntityUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: EntityWhereUniqueInput;
}

export interface ContactWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  homePhone?: String;
  homePhone_not?: String;
  homePhone_in?: String[] | String;
  homePhone_not_in?: String[] | String;
  homePhone_lt?: String;
  homePhone_lte?: String;
  homePhone_gt?: String;
  homePhone_gte?: String;
  homePhone_contains?: String;
  homePhone_not_contains?: String;
  homePhone_starts_with?: String;
  homePhone_not_starts_with?: String;
  homePhone_ends_with?: String;
  homePhone_not_ends_with?: String;
  officePhone?: String;
  officePhone_not?: String;
  officePhone_in?: String[] | String;
  officePhone_not_in?: String[] | String;
  officePhone_lt?: String;
  officePhone_lte?: String;
  officePhone_gt?: String;
  officePhone_gte?: String;
  officePhone_contains?: String;
  officePhone_not_contains?: String;
  officePhone_starts_with?: String;
  officePhone_not_starts_with?: String;
  officePhone_ends_with?: String;
  officePhone_not_ends_with?: String;
  cellPhone?: String;
  cellPhone_not?: String;
  cellPhone_in?: String[] | String;
  cellPhone_not_in?: String[] | String;
  cellPhone_lt?: String;
  cellPhone_lte?: String;
  cellPhone_gt?: String;
  cellPhone_gte?: String;
  cellPhone_contains?: String;
  cellPhone_not_contains?: String;
  cellPhone_starts_with?: String;
  cellPhone_not_starts_with?: String;
  cellPhone_ends_with?: String;
  cellPhone_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  wechat?: String;
  wechat_not?: String;
  wechat_in?: String[] | String;
  wechat_not_in?: String[] | String;
  wechat_lt?: String;
  wechat_lte?: String;
  wechat_gt?: String;
  wechat_gte?: String;
  wechat_contains?: String;
  wechat_not_contains?: String;
  wechat_starts_with?: String;
  wechat_not_starts_with?: String;
  wechat_ends_with?: String;
  wechat_not_ends_with?: String;
  whatsapp?: String;
  whatsapp_not?: String;
  whatsapp_in?: String[] | String;
  whatsapp_not_in?: String[] | String;
  whatsapp_lt?: String;
  whatsapp_lte?: String;
  whatsapp_gt?: String;
  whatsapp_gte?: String;
  whatsapp_contains?: String;
  whatsapp_not_contains?: String;
  whatsapp_starts_with?: String;
  whatsapp_not_starts_with?: String;
  whatsapp_ends_with?: String;
  whatsapp_not_ends_with?: String;
  github?: String;
  github_not?: String;
  github_in?: String[] | String;
  github_not_in?: String[] | String;
  github_lt?: String;
  github_lte?: String;
  github_gt?: String;
  github_gte?: String;
  github_contains?: String;
  github_not_contains?: String;
  github_starts_with?: String;
  github_not_starts_with?: String;
  github_ends_with?: String;
  github_not_ends_with?: String;
  twitter?: String;
  twitter_not?: String;
  twitter_in?: String[] | String;
  twitter_not_in?: String[] | String;
  twitter_lt?: String;
  twitter_lte?: String;
  twitter_gt?: String;
  twitter_gte?: String;
  twitter_contains?: String;
  twitter_not_contains?: String;
  twitter_starts_with?: String;
  twitter_not_starts_with?: String;
  twitter_ends_with?: String;
  twitter_not_ends_with?: String;
  instagram?: String;
  instagram_not?: String;
  instagram_in?: String[] | String;
  instagram_not_in?: String[] | String;
  instagram_lt?: String;
  instagram_lte?: String;
  instagram_gt?: String;
  instagram_gte?: String;
  instagram_contains?: String;
  instagram_not_contains?: String;
  instagram_starts_with?: String;
  instagram_not_starts_with?: String;
  instagram_ends_with?: String;
  instagram_not_ends_with?: String;
  homepage?: String;
  homepage_not?: String;
  homepage_in?: String[] | String;
  homepage_not_in?: String[] | String;
  homepage_lt?: String;
  homepage_lte?: String;
  homepage_gt?: String;
  homepage_gte?: String;
  homepage_contains?: String;
  homepage_not_contains?: String;
  homepage_starts_with?: String;
  homepage_not_starts_with?: String;
  homepage_ends_with?: String;
  homepage_not_ends_with?: String;
  avatar?: String;
  avatar_not?: String;
  avatar_in?: String[] | String;
  avatar_not_in?: String[] | String;
  avatar_lt?: String;
  avatar_lte?: String;
  avatar_gt?: String;
  avatar_gte?: String;
  avatar_contains?: String;
  avatar_not_contains?: String;
  avatar_starts_with?: String;
  avatar_not_starts_with?: String;
  avatar_ends_with?: String;
  avatar_not_ends_with?: String;
  AND?: ContactWhereInput[] | ContactWhereInput;
  OR?: ContactWhereInput[] | ContactWhereInput;
  NOT?: ContactWhereInput[] | ContactWhereInput;
}

export interface DocumentUpsertWithWhereUniqueWithoutAuthorInput {
  where: DocumentWhereUniqueInput;
  update: DocumentUpdateWithoutAuthorDataInput;
  create: DocumentCreateWithoutAuthorInput;
}

export interface ItemProcedureWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  previousPlace?: String;
  previousPlace_not?: String;
  previousPlace_in?: String[] | String;
  previousPlace_not_in?: String[] | String;
  previousPlace_lt?: String;
  previousPlace_lte?: String;
  previousPlace_gt?: String;
  previousPlace_gte?: String;
  previousPlace_contains?: String;
  previousPlace_not_contains?: String;
  previousPlace_starts_with?: String;
  previousPlace_not_starts_with?: String;
  previousPlace_ends_with?: String;
  previousPlace_not_ends_with?: String;
  currentPlace?: String;
  currentPlace_not?: String;
  currentPlace_in?: String[] | String;
  currentPlace_not_in?: String[] | String;
  currentPlace_lt?: String;
  currentPlace_lte?: String;
  currentPlace_gt?: String;
  currentPlace_gte?: String;
  currentPlace_contains?: String;
  currentPlace_not_contains?: String;
  currentPlace_starts_with?: String;
  currentPlace_not_starts_with?: String;
  currentPlace_ends_with?: String;
  currentPlace_not_ends_with?: String;
  devaluation?: String;
  devaluation_not?: String;
  devaluation_in?: String[] | String;
  devaluation_not_in?: String[] | String;
  devaluation_lt?: String;
  devaluation_lte?: String;
  devaluation_gt?: String;
  devaluation_gte?: String;
  devaluation_contains?: String;
  devaluation_not_contains?: String;
  devaluation_starts_with?: String;
  devaluation_not_starts_with?: String;
  devaluation_ends_with?: String;
  devaluation_not_ends_with?: String;
  procedureState?: ProcedureWhereInput;
  AND?: ItemProcedureWhereInput[] | ItemProcedureWhereInput;
  OR?: ItemProcedureWhereInput[] | ItemProcedureWhereInput;
  NOT?: ItemProcedureWhereInput[] | ItemProcedureWhereInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface PartyEntityUpdateInput {
  name?: String;
  fullName?: String;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
}

export interface UserUpdateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  update?:
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput;
  upsert?:
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface EntityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  fullName?: String;
  fullName_not?: String;
  fullName_in?: String[] | String;
  fullName_not_in?: String[] | String;
  fullName_lt?: String;
  fullName_lte?: String;
  fullName_gt?: String;
  fullName_gte?: String;
  fullName_contains?: String;
  fullName_not_contains?: String;
  fullName_starts_with?: String;
  fullName_not_starts_with?: String;
  fullName_ends_with?: String;
  fullName_not_ends_with?: String;
  abbr?: String;
  abbr_not?: String;
  abbr_in?: String[] | String;
  abbr_not_in?: String[] | String;
  abbr_lt?: String;
  abbr_lte?: String;
  abbr_gt?: String;
  abbr_gte?: String;
  abbr_contains?: String;
  abbr_not_contains?: String;
  abbr_starts_with?: String;
  abbr_not_starts_with?: String;
  abbr_ends_with?: String;
  abbr_not_ends_with?: String;
  address?: AddressWhereInput;
  avatar?: String;
  avatar_not?: String;
  avatar_in?: String[] | String;
  avatar_not_in?: String[] | String;
  avatar_lt?: String;
  avatar_lte?: String;
  avatar_gt?: String;
  avatar_gte?: String;
  avatar_contains?: String;
  avatar_not_contains?: String;
  avatar_starts_with?: String;
  avatar_not_starts_with?: String;
  avatar_ends_with?: String;
  avatar_not_ends_with?: String;
  AND?: EntityWhereInput[] | EntityWhereInput;
  OR?: EntityWhereInput[] | EntityWhereInput;
  NOT?: EntityWhereInput[] | EntityWhereInput;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface UserUpdateOneInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export type ProcedureWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BussinessTripUpdateroutesInput {
  set?: String[] | String;
}

export interface ActivityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  address?: AddressWhereInput;
  occurrenceDate?: DateTimeInput;
  occurrenceDate_not?: DateTimeInput;
  occurrenceDate_in?: DateTimeInput[] | DateTimeInput;
  occurrenceDate_not_in?: DateTimeInput[] | DateTimeInput;
  occurrenceDate_lt?: DateTimeInput;
  occurrenceDate_lte?: DateTimeInput;
  occurrenceDate_gt?: DateTimeInput;
  occurrenceDate_gte?: DateTimeInput;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  applicant?: UserWhereInput;
  participants_every?: UserWhereInput;
  participants_some?: UserWhereInput;
  participants_none?: UserWhereInput;
  currentDate?: DateTimeInput;
  currentDate_not?: DateTimeInput;
  currentDate_in?: DateTimeInput[] | DateTimeInput;
  currentDate_not_in?: DateTimeInput[] | DateTimeInput;
  currentDate_lt?: DateTimeInput;
  currentDate_lte?: DateTimeInput;
  currentDate_gt?: DateTimeInput;
  currentDate_gte?: DateTimeInput;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  endTime?: DateTimeInput;
  endTime_not?: DateTimeInput;
  endTime_in?: DateTimeInput[] | DateTimeInput;
  endTime_not_in?: DateTimeInput[] | DateTimeInput;
  endTime_lt?: DateTimeInput;
  endTime_lte?: DateTimeInput;
  endTime_gt?: DateTimeInput;
  endTime_gte?: DateTimeInput;
  reporter_every?: UserWhereInput;
  reporter_some?: UserWhereInput;
  reporter_none?: UserWhereInput;
  reportDate?: DateTimeInput;
  reportDate_not?: DateTimeInput;
  reportDate_in?: DateTimeInput[] | DateTimeInput;
  reportDate_not_in?: DateTimeInput[] | DateTimeInput;
  reportDate_lt?: DateTimeInput;
  reportDate_lte?: DateTimeInput;
  reportDate_gt?: DateTimeInput;
  reportDate_gte?: DateTimeInput;
  reportContent?: String;
  reportContent_not?: String;
  reportContent_in?: String[] | String;
  reportContent_not_in?: String[] | String;
  reportContent_lt?: String;
  reportContent_lte?: String;
  reportContent_gt?: String;
  reportContent_gte?: String;
  reportContent_contains?: String;
  reportContent_not_contains?: String;
  reportContent_starts_with?: String;
  reportContent_not_starts_with?: String;
  reportContent_ends_with?: String;
  reportContent_not_ends_with?: String;
  instructor_every?: UserWhereInput;
  instructor_some?: UserWhereInput;
  instructor_none?: UserWhereInput;
  instructionDate?: DateTimeInput;
  instructionDate_not?: DateTimeInput;
  instructionDate_in?: DateTimeInput[] | DateTimeInput;
  instructionDate_not_in?: DateTimeInput[] | DateTimeInput;
  instructionDate_lt?: DateTimeInput;
  instructionDate_lte?: DateTimeInput;
  instructionDate_gt?: DateTimeInput;
  instructionDate_gte?: DateTimeInput;
  instruction?: String;
  instruction_not?: String;
  instruction_in?: String[] | String;
  instruction_not_in?: String[] | String;
  instruction_lt?: String;
  instruction_lte?: String;
  instruction_gt?: String;
  instruction_gte?: String;
  instruction_contains?: String;
  instruction_not_contains?: String;
  instruction_starts_with?: String;
  instruction_not_starts_with?: String;
  instruction_ends_with?: String;
  instruction_not_ends_with?: String;
  priority?: PriorityLevel;
  priority_not?: PriorityLevel;
  priority_in?: PriorityLevel[] | PriorityLevel;
  priority_not_in?: PriorityLevel[] | PriorityLevel;
  AND?: ActivityWhereInput[] | ActivityWhereInput;
  OR?: ActivityWhereInput[] | ActivityWhereInput;
  NOT?: ActivityWhereInput[] | ActivityWhereInput;
}

export interface BussinessTripUpdateInput {
  applicant?: UserUpdateManyInput;
  purpose?: String;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  routes?: BussinessTripUpdateroutesInput;
  flightTicket?: String;
  hotelRoom?: String;
  transport?: String;
}

export interface BanqueteSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BanqueteWhereInput;
  AND?: BanqueteSubscriptionWhereInput[] | BanqueteSubscriptionWhereInput;
  OR?: BanqueteSubscriptionWhereInput[] | BanqueteSubscriptionWhereInput;
  NOT?: BanqueteSubscriptionWhereInput[] | BanqueteSubscriptionWhereInput;
}

export interface AddressUpdateInput {
  street?: String;
  suite?: String;
  area?: String;
  city?: String;
  state?: String;
  country?: String;
  zipcode?: String;
  geo?: LocationUpdateOneInput;
}

export interface ProcedureWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  deadline?: DateTimeInput;
  deadline_not?: DateTimeInput;
  deadline_in?: DateTimeInput[] | DateTimeInput;
  deadline_not_in?: DateTimeInput[] | DateTimeInput;
  deadline_lt?: DateTimeInput;
  deadline_lte?: DateTimeInput;
  deadline_gt?: DateTimeInput;
  deadline_gte?: DateTimeInput;
  progress?: Float;
  progress_not?: Float;
  progress_in?: Float[] | Float;
  progress_not_in?: Float[] | Float;
  progress_lt?: Float;
  progress_lte?: Float;
  progress_gt?: Float;
  progress_gte?: Float;
  color?: String;
  color_not?: String;
  color_in?: String[] | String;
  color_not_in?: String[] | String;
  color_lt?: String;
  color_lte?: String;
  color_gt?: String;
  color_gte?: String;
  color_contains?: String;
  color_not_contains?: String;
  color_starts_with?: String;
  color_not_starts_with?: String;
  color_ends_with?: String;
  color_not_ends_with?: String;
  previousProcedure?: ProcedureWhereInput;
  nextProcedure?: ProcedureWhereInput;
  users_every?: UserWhereInput;
  users_some?: UserWhereInput;
  users_none?: UserWhereInput;
  documents_every?: DocumentWhereInput;
  documents_some?: DocumentWhereInput;
  documents_none?: DocumentWhereInput;
  entities_every?: EntityWhereInput;
  entities_some?: EntityWhereInput;
  entities_none?: EntityWhereInput;
  AND?: ProcedureWhereInput[] | ProcedureWhereInput;
  OR?: ProcedureWhereInput[] | ProcedureWhereInput;
  NOT?: ProcedureWhereInput[] | ProcedureWhereInput;
}

export interface ArticleCreateInput {
  author: String;
  title: String;
  tags?: ArticleCreatetagsInput;
  isPublished?: Boolean;
  description?: String;
  text?: String;
  featuredImage?: String;
  format?: ArticleFormat;
  publishDate?: DateTimeInput;
}

export type ItemWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ArticleCreatetagsInput {
  set?: String[] | String;
}

export interface ItemProcedureUpdateInput {
  previousPlace?: String;
  currentPlace?: String;
  devaluation?: String;
  procedureState?: ProcedureUpdateOneRequiredInput;
}

export interface ArticleUpdateInput {
  author?: String;
  title?: String;
  tags?: ArticleUpdatetagsInput;
  isPublished?: Boolean;
  description?: String;
  text?: String;
  featuredImage?: String;
  format?: ArticleFormat;
  publishDate?: DateTimeInput;
}

export interface EvaluationProcedureCreateInput {
  target: UserCreateOneInput;
  positiveObservation?: String;
  negativeObservation?: String;
  expectation?: String;
  performanceLevel: String;
  proposal?: String;
  directSuperior: UserCreateOneInput;
  headOfInstitution?: UserCreateOneInput;
  procedureState: ProcedureCreateOneInput;
}

export interface ArticleUpdatetagsInput {
  set?: String[] | String;
}

export interface EvaluationProcedureSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EvaluationProcedureWhereInput;
  AND?:
    | EvaluationProcedureSubscriptionWhereInput[]
    | EvaluationProcedureSubscriptionWhereInput;
  OR?:
    | EvaluationProcedureSubscriptionWhereInput[]
    | EvaluationProcedureSubscriptionWhereInput;
  NOT?:
    | EvaluationProcedureSubscriptionWhereInput[]
    | EvaluationProcedureSubscriptionWhereInput;
}

export interface BanqueteCreateInput {
  applicant: String;
  purpose: String;
  offerer: UserCreateOneInput;
  authorizer: UserCreateOneInput;
  companions?: UserCreateManyInput;
  guests?: UserCreateManyInput;
  place: EntityCreateOneInput;
  date: DateTimeInput;
  description?: String;
  total: String;
  tags?: BanqueteCreatetagsInput;
}

export interface ItemUpdateWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateDataInput;
}

export interface BussinessTripCreateInput {
  applicant?: UserCreateManyInput;
  purpose: String;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
  routes?: BussinessTripCreateroutesInput;
  flightTicket?: String;
  hotelRoom?: String;
  transport?: String;
}

export interface BanqueteUpdatetagsInput {
  set?: String[] | String;
}

export interface BanqueteUpdateInput {
  applicant?: String;
  purpose?: String;
  offerer?: UserUpdateOneRequiredInput;
  authorizer?: UserUpdateOneRequiredInput;
  companions?: UserUpdateManyInput;
  guests?: UserUpdateManyInput;
  place?: EntityUpdateOneRequiredInput;
  date?: DateTimeInput;
  description?: String;
  total?: String;
  tags?: BanqueteUpdatetagsInput;
}

export interface BanqueteCreatetagsInput {
  set?: String[] | String;
}

export interface PersonCreateInput {
  name: String;
  gender: String;
  birthday: DateTimeInput;
}

export interface UserUpdateInput {
  protocolId?: String;
  name?: String;
  gender?: String;
  position?: String;
  etnia?: String;
  birthday?: DateTimeInput;
  academicBackground?: String;
  foreignLanguage?: String;
  politicalRole?: String;
  rank?: String;
  promotionDate?: DateTimeInput;
  outRole?: String;
  innerRole?: String;
  chargeOf?: String;
  sendingEntity?: String;
  arrivingDate?: DateTimeInput;
  leavingDate?: DateTimeInput;
  fromEntity?: String;
  memo?: String;
  contact?: ContactUpdateOneInput;
  partyMembership?: PartyMembershipUpdateOneInput;
  documents?: DocumentUpdateManyWithoutAuthorInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export type PartyMembershipWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface NodeNode {
  id: ID_Output;
}

export interface VacationPreviousValuesNode {
  id: ID_Output;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
  routes: Route;
  type: VacationType;
  flightTicket: String;
  hotelRoom: String;
  transport: String;
}

export interface VacationPreviousValues
  extends Promise<VacationPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  routes: () => Promise<Route>;
  type: () => Promise<VacationType>;
  flightTicket: () => Promise<String>;
  hotelRoom: () => Promise<String>;
  transport: () => Promise<String>;
}

export interface VacationPreviousValuesSubscription
  extends Promise<AsyncIterator<VacationPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  routes: () => Promise<AsyncIterator<Route>>;
  type: () => Promise<AsyncIterator<VacationType>>;
  flightTicket: () => Promise<AsyncIterator<String>>;
  hotelRoom: () => Promise<AsyncIterator<String>>;
  transport: () => Promise<AsyncIterator<String>>;
}

export interface DocumentProcedureNode {
  id: ID_Output;
  from: String;
  to: String;
}

export interface DocumentProcedure
  extends Promise<DocumentProcedureNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  from: () => Promise<String>;
  to: () => Promise<String>;
  procedureState: <T = Procedure>() => T;
}

export interface DocumentProcedureSubscription
  extends Promise<AsyncIterator<DocumentProcedureNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  from: () => Promise<AsyncIterator<String>>;
  to: () => Promise<AsyncIterator<String>>;
  procedureState: <T = ProcedureSubscription>() => T;
}

export interface TransactionPreviousValuesNode {
  id: ID_Output;
  name: String;
  place?: String;
  date: DateTimeOutput;
  description?: String;
  applicant: String;
  quantity?: Int;
  total: String;
  type: TransactionType;
  tags: String[];
}

export interface TransactionPreviousValues
  extends Promise<TransactionPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  place: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  applicant: () => Promise<String>;
  quantity: () => Promise<Int>;
  total: () => Promise<String>;
  type: () => Promise<TransactionType>;
  tags: () => Promise<String[]>;
}

export interface TransactionPreviousValuesSubscription
  extends Promise<AsyncIterator<TransactionPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  place: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  applicant: () => Promise<AsyncIterator<String>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  total: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<TransactionType>>;
  tags: () => Promise<AsyncIterator<String[]>>;
}

export interface AggregateDocumentNode {
  count: Int;
}

export interface AggregateDocument
  extends Promise<AggregateDocumentNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDocumentSubscription
  extends Promise<AsyncIterator<AggregateDocumentNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DocumentConnectionNode {}

export interface DocumentConnection
  extends Promise<DocumentConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<DocumentEdgeNode>>() => T;
  aggregate: <T = AggregateDocument>() => T;
}

export interface DocumentConnectionSubscription
  extends Promise<AsyncIterator<DocumentConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DocumentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDocumentSubscription>() => T;
}

export interface DocumentEdgeNode {
  cursor: String;
}

export interface DocumentEdge extends Promise<DocumentEdgeNode>, Fragmentable {
  node: <T = Document>() => T;
  cursor: () => Promise<String>;
}

export interface DocumentEdgeSubscription
  extends Promise<AsyncIterator<DocumentEdgeNode>>,
    Fragmentable {
  node: <T = DocumentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface VacationSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface VacationSubscriptionPayload
  extends Promise<VacationSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Vacation>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VacationPreviousValues>() => T;
}

export interface VacationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VacationSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VacationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VacationPreviousValuesSubscription>() => T;
}

export interface BatchPayloadNode {
  count: Long;
}

export interface BatchPayload extends Promise<BatchPayloadNode>, Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayloadNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface VacationEdgeNode {
  cursor: String;
}

export interface VacationEdge extends Promise<VacationEdgeNode>, Fragmentable {
  node: <T = Vacation>() => T;
  cursor: () => Promise<String>;
}

export interface VacationEdgeSubscription
  extends Promise<AsyncIterator<VacationEdgeNode>>,
    Fragmentable {
  node: <T = VacationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateContactNode {
  count: Int;
}

export interface AggregateContact
  extends Promise<AggregateContactNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContactSubscription
  extends Promise<AsyncIterator<AggregateContactNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AddressNode {
  id: ID_Output;
  street: String;
  suite: String;
  area: String;
  city: String;
  state: String;
  country: String;
  zipcode?: String;
}

export interface Address extends Promise<AddressNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  street: () => Promise<String>;
  suite: () => Promise<String>;
  area: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  country: () => Promise<String>;
  zipcode: () => Promise<String>;
  geo: <T = Location>() => T;
}

export interface AddressSubscription
  extends Promise<AsyncIterator<AddressNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  street: () => Promise<AsyncIterator<String>>;
  suite: () => Promise<AsyncIterator<String>>;
  area: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  zipcode: () => Promise<AsyncIterator<String>>;
  geo: <T = LocationSubscription>() => T;
}

export interface ContactEdgeNode {
  cursor: String;
}

export interface ContactEdge extends Promise<ContactEdgeNode>, Fragmentable {
  node: <T = Contact>() => T;
  cursor: () => Promise<String>;
}

export interface ContactEdgeSubscription
  extends Promise<AsyncIterator<ContactEdgeNode>>,
    Fragmentable {
  node: <T = ContactSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LocationNode {
  id: ID_Output;
  latitude: Float;
  longitude: Float;
}

export interface Location extends Promise<LocationNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  latitude: () => Promise<Float>;
  longitude: () => Promise<Float>;
}

export interface LocationSubscription
  extends Promise<AsyncIterator<LocationNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  latitude: () => Promise<AsyncIterator<Float>>;
  longitude: () => Promise<AsyncIterator<Float>>;
}

export interface ContactConnectionNode {}

export interface ContactConnection
  extends Promise<ContactConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ContactEdgeNode>>() => T;
  aggregate: <T = AggregateContact>() => T;
}

export interface ContactConnectionSubscription
  extends Promise<AsyncIterator<ContactConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContactEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContactSubscription>() => T;
}

export interface AggregateUserNode {
  count: Int;
}

export interface AggregateUser
  extends Promise<AggregateUserNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUserNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ActivityNode {
  id: ID_Output;
  occurrenceDate: DateTimeOutput;
  content: String;
  currentDate: DateTimeOutput;
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
  reportDate: DateTimeOutput;
  reportContent: String;
  instructionDate: DateTimeOutput;
  instruction: String;
  priority: PriorityLevel;
}

export interface Activity extends Promise<ActivityNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  address: <T = Address>() => T;
  occurrenceDate: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
  applicant: <T = User>() => T;
  participants: <T = FragmentableArray<UserNode>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  currentDate: () => Promise<DateTimeOutput>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  reporter: <T = FragmentableArray<UserNode>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  reportDate: () => Promise<DateTimeOutput>;
  reportContent: () => Promise<String>;
  instructor: <T = FragmentableArray<UserNode>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  instructionDate: () => Promise<DateTimeOutput>;
  instruction: () => Promise<String>;
  priority: () => Promise<PriorityLevel>;
}

export interface ActivitySubscription
  extends Promise<AsyncIterator<ActivityNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  address: <T = AddressSubscription>() => T;
  occurrenceDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
  applicant: <T = UserSubscription>() => T;
  participants: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  currentDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  reporter: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  reportDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  reportContent: () => Promise<AsyncIterator<String>>;
  instructor: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  instructionDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  instruction: () => Promise<AsyncIterator<String>>;
  priority: () => Promise<AsyncIterator<PriorityLevel>>;
}

export interface UserConnectionNode {}

export interface UserConnection
  extends Promise<UserConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<UserEdgeNode>>() => T;
  aggregate: <T = AggregateUser>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface ActivitySubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ActivitySubscriptionPayload
  extends Promise<ActivitySubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Activity>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActivityPreviousValues>() => T;
}

export interface ActivitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActivitySubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActivitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ActivityPreviousValuesSubscription>() => T;
}

export interface TransactionEdgeNode {
  cursor: String;
}

export interface TransactionEdge
  extends Promise<TransactionEdgeNode>,
    Fragmentable {
  node: <T = Transaction>() => T;
  cursor: () => Promise<String>;
}

export interface TransactionEdgeSubscription
  extends Promise<AsyncIterator<TransactionEdgeNode>>,
    Fragmentable {
  node: <T = TransactionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ActivityPreviousValuesNode {
  id: ID_Output;
  occurrenceDate: DateTimeOutput;
  content: String;
  currentDate: DateTimeOutput;
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
  reportDate: DateTimeOutput;
  reportContent: String;
  instructionDate: DateTimeOutput;
  instruction: String;
  priority: PriorityLevel;
}

export interface ActivityPreviousValues
  extends Promise<ActivityPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  occurrenceDate: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
  currentDate: () => Promise<DateTimeOutput>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  reportDate: () => Promise<DateTimeOutput>;
  reportContent: () => Promise<String>;
  instructionDate: () => Promise<DateTimeOutput>;
  instruction: () => Promise<String>;
  priority: () => Promise<PriorityLevel>;
}

export interface ActivityPreviousValuesSubscription
  extends Promise<AsyncIterator<ActivityPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  occurrenceDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
  currentDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  reportDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  reportContent: () => Promise<AsyncIterator<String>>;
  instructionDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  instruction: () => Promise<AsyncIterator<String>>;
  priority: () => Promise<AsyncIterator<PriorityLevel>>;
}

export interface UserPreviousValuesNode {
  id: ID_Output;
  protocolId?: String;
  name: String;
  gender: String;
  position?: String;
  etnia: String;
  birthday: DateTimeOutput;
  academicBackground?: String;
  foreignLanguage?: String;
  politicalRole?: String;
  rank?: String;
  promotionDate?: DateTimeOutput;
  outRole?: String;
  innerRole?: String;
  chargeOf?: String;
  sendingEntity?: String;
  arrivingDate?: DateTimeOutput;
  leavingDate?: DateTimeOutput;
  fromEntity?: String;
  memo?: String;
}

export interface UserPreviousValues
  extends Promise<UserPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  protocolId: () => Promise<String>;
  name: () => Promise<String>;
  gender: () => Promise<String>;
  position: () => Promise<String>;
  etnia: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  academicBackground: () => Promise<String>;
  foreignLanguage: () => Promise<String>;
  politicalRole: () => Promise<String>;
  rank: () => Promise<String>;
  promotionDate: () => Promise<DateTimeOutput>;
  outRole: () => Promise<String>;
  innerRole: () => Promise<String>;
  chargeOf: () => Promise<String>;
  sendingEntity: () => Promise<String>;
  arrivingDate: () => Promise<DateTimeOutput>;
  leavingDate: () => Promise<DateTimeOutput>;
  fromEntity: () => Promise<String>;
  memo: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  protocolId: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  position: () => Promise<AsyncIterator<String>>;
  etnia: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  academicBackground: () => Promise<AsyncIterator<String>>;
  foreignLanguage: () => Promise<AsyncIterator<String>>;
  politicalRole: () => Promise<AsyncIterator<String>>;
  rank: () => Promise<AsyncIterator<String>>;
  promotionDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  outRole: () => Promise<AsyncIterator<String>>;
  innerRole: () => Promise<AsyncIterator<String>>;
  chargeOf: () => Promise<AsyncIterator<String>>;
  sendingEntity: () => Promise<AsyncIterator<String>>;
  arrivingDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  leavingDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  fromEntity: () => Promise<AsyncIterator<String>>;
  memo: () => Promise<AsyncIterator<String>>;
}

export interface PageInfoNode {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfo extends Promise<PageInfoNode>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfoNode>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface TransactionNode {
  id: ID_Output;
  name: String;
  place?: String;
  date: DateTimeOutput;
  description?: String;
  applicant: String;
  quantity?: Int;
  total: String;
  type: TransactionType;
  tags: String[];
}

export interface Transaction extends Promise<TransactionNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  place: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  applicant: () => Promise<String>;
  item: <T = Item>() => T;
  quantity: () => Promise<Int>;
  total: () => Promise<String>;
  type: () => Promise<TransactionType>;
  tags: () => Promise<String[]>;
}

export interface TransactionSubscription
  extends Promise<AsyncIterator<TransactionNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  place: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  applicant: () => Promise<AsyncIterator<String>>;
  item: <T = ItemSubscription>() => T;
  quantity: () => Promise<AsyncIterator<Int>>;
  total: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<TransactionType>>;
  tags: () => Promise<AsyncIterator<String[]>>;
}

export interface AddressSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface AddressSubscriptionPayload
  extends Promise<AddressSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Address>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AddressPreviousValues>() => T;
}

export interface AddressSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AddressSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AddressSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AddressPreviousValuesSubscription>() => T;
}

export interface StorageEdgeNode {
  cursor: String;
}

export interface StorageEdge extends Promise<StorageEdgeNode>, Fragmentable {
  node: <T = Storage>() => T;
  cursor: () => Promise<String>;
}

export interface StorageEdgeSubscription
  extends Promise<AsyncIterator<StorageEdgeNode>>,
    Fragmentable {
  node: <T = StorageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AddressPreviousValuesNode {
  id: ID_Output;
  street: String;
  suite: String;
  area: String;
  city: String;
  state: String;
  country: String;
  zipcode?: String;
}

export interface AddressPreviousValues
  extends Promise<AddressPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  street: () => Promise<String>;
  suite: () => Promise<String>;
  area: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  country: () => Promise<String>;
  zipcode: () => Promise<String>;
}

export interface AddressPreviousValuesSubscription
  extends Promise<AsyncIterator<AddressPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  street: () => Promise<AsyncIterator<String>>;
  suite: () => Promise<AsyncIterator<String>>;
  area: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  zipcode: () => Promise<AsyncIterator<String>>;
}

export interface UserNode {
  id: ID_Output;
  protocolId?: String;
  name: String;
  gender: String;
  position?: String;
  etnia: String;
  birthday: DateTimeOutput;
  academicBackground?: String;
  foreignLanguage?: String;
  politicalRole?: String;
  rank?: String;
  promotionDate?: DateTimeOutput;
  outRole?: String;
  innerRole?: String;
  chargeOf?: String;
  sendingEntity?: String;
  arrivingDate?: DateTimeOutput;
  leavingDate?: DateTimeOutput;
  fromEntity?: String;
  memo?: String;
}

export interface User extends Promise<UserNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  protocolId: () => Promise<String>;
  name: () => Promise<String>;
  gender: () => Promise<String>;
  position: () => Promise<String>;
  etnia: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  academicBackground: () => Promise<String>;
  foreignLanguage: () => Promise<String>;
  politicalRole: () => Promise<String>;
  rank: () => Promise<String>;
  promotionDate: () => Promise<DateTimeOutput>;
  outRole: () => Promise<String>;
  innerRole: () => Promise<String>;
  chargeOf: () => Promise<String>;
  sendingEntity: () => Promise<String>;
  arrivingDate: () => Promise<DateTimeOutput>;
  leavingDate: () => Promise<DateTimeOutput>;
  fromEntity: () => Promise<String>;
  memo: () => Promise<String>;
  contact: <T = Contact>() => T;
  partyMembership: <T = PartyMembership>() => T;
  documents: <T = FragmentableArray<DocumentNode>>(
    args?: {
      where?: DocumentWhereInput;
      orderBy?: DocumentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<UserNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  protocolId: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  position: () => Promise<AsyncIterator<String>>;
  etnia: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  academicBackground: () => Promise<AsyncIterator<String>>;
  foreignLanguage: () => Promise<AsyncIterator<String>>;
  politicalRole: () => Promise<AsyncIterator<String>>;
  rank: () => Promise<AsyncIterator<String>>;
  promotionDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  outRole: () => Promise<AsyncIterator<String>>;
  innerRole: () => Promise<AsyncIterator<String>>;
  chargeOf: () => Promise<AsyncIterator<String>>;
  sendingEntity: () => Promise<AsyncIterator<String>>;
  arrivingDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  leavingDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  fromEntity: () => Promise<AsyncIterator<String>>;
  memo: () => Promise<AsyncIterator<String>>;
  contact: <T = ContactSubscription>() => T;
  partyMembership: <T = PartyMembershipSubscription>() => T;
  documents: <T = Promise<AsyncIterator<DocumentSubscription>>>(
    args?: {
      where?: DocumentWhereInput;
      orderBy?: DocumentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateBussinessTripNode {
  count: Int;
}

export interface AggregateBussinessTrip
  extends Promise<AggregateBussinessTripNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBussinessTripSubscription
  extends Promise<AsyncIterator<AggregateBussinessTripNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregatePromotionProcedureNode {
  count: Int;
}

export interface AggregatePromotionProcedure
  extends Promise<AggregatePromotionProcedureNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePromotionProcedureSubscription
  extends Promise<AsyncIterator<AggregatePromotionProcedureNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ArticleSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ArticleSubscriptionPayload
  extends Promise<ArticleSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Article>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ArticlePreviousValues>() => T;
}

export interface ArticleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ArticleSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ArticleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ArticlePreviousValuesSubscription>() => T;
}

export interface PromotionProcedureConnectionNode {}

export interface PromotionProcedureConnection
  extends Promise<PromotionProcedureConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<PromotionProcedureEdgeNode>>() => T;
  aggregate: <T = AggregatePromotionProcedure>() => T;
}

export interface PromotionProcedureConnectionSubscription
  extends Promise<AsyncIterator<PromotionProcedureConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<PromotionProcedureEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregatePromotionProcedureSubscription>() => T;
}

export interface ArticlePreviousValuesNode {
  id: ID_Output;
  author: String;
  title: String;
  tags: String[];
  isPublished: Boolean;
  description?: String;
  text?: String;
  featuredImage?: String;
  format?: ArticleFormat;
  publishDate: DateTimeOutput;
}

export interface ArticlePreviousValues
  extends Promise<ArticlePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  author: () => Promise<String>;
  title: () => Promise<String>;
  tags: () => Promise<String[]>;
  isPublished: () => Promise<Boolean>;
  description: () => Promise<String>;
  text: () => Promise<String>;
  featuredImage: () => Promise<String>;
  format: () => Promise<ArticleFormat>;
  publishDate: () => Promise<DateTimeOutput>;
}

export interface ArticlePreviousValuesSubscription
  extends Promise<AsyncIterator<ArticlePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  author: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String[]>>;
  isPublished: () => Promise<AsyncIterator<Boolean>>;
  description: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  featuredImage: () => Promise<AsyncIterator<String>>;
  format: () => Promise<AsyncIterator<ArticleFormat>>;
  publishDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PromotionProcedureNode {
  id: ID_Output;
  previousRank: String;
  currentRank: String;
  promitionDate: DateTimeOutput;
  previousSalary: String;
  currentSalary: String;
}

export interface PromotionProcedure
  extends Promise<PromotionProcedureNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  previousRank: () => Promise<String>;
  currentRank: () => Promise<String>;
  promitionDate: () => Promise<DateTimeOutput>;
  previousSalary: () => Promise<String>;
  currentSalary: () => Promise<String>;
  procedureState: <T = Procedure>() => T;
}

export interface PromotionProcedureSubscription
  extends Promise<AsyncIterator<PromotionProcedureNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  previousRank: () => Promise<AsyncIterator<String>>;
  currentRank: () => Promise<AsyncIterator<String>>;
  promitionDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  previousSalary: () => Promise<AsyncIterator<String>>;
  currentSalary: () => Promise<AsyncIterator<String>>;
  procedureState: <T = ProcedureSubscription>() => T;
}

export interface BussinessTripEdgeNode {
  cursor: String;
}

export interface BussinessTripEdge
  extends Promise<BussinessTripEdgeNode>,
    Fragmentable {
  node: <T = BussinessTrip>() => T;
  cursor: () => Promise<String>;
}

export interface BussinessTripEdgeSubscription
  extends Promise<AsyncIterator<BussinessTripEdgeNode>>,
    Fragmentable {
  node: <T = BussinessTripSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProcedureEdgeNode {
  cursor: String;
}

export interface ProcedureEdge
  extends Promise<ProcedureEdgeNode>,
    Fragmentable {
  node: <T = Procedure>() => T;
  cursor: () => Promise<String>;
}

export interface ProcedureEdgeSubscription
  extends Promise<AsyncIterator<ProcedureEdgeNode>>,
    Fragmentable {
  node: <T = ProcedureSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BanqueteSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface BanqueteSubscriptionPayload
  extends Promise<BanqueteSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Banquete>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BanquetePreviousValues>() => T;
}

export interface BanqueteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BanqueteSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BanqueteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BanquetePreviousValuesSubscription>() => T;
}

export interface PartyMembershipNode {
  id: ID_Output;
  name: String;
  preEnrollDate: DateTimeOutput;
  EnrollDate: DateTimeOutput;
  registerInDate: DateTimeOutput;
  registerOutDate: DateTimeOutput;
  membershipState: String;
}

export interface PartyMembership
  extends Promise<PartyMembershipNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  preEnrollDate: () => Promise<DateTimeOutput>;
  EnrollDate: () => Promise<DateTimeOutput>;
  registerInDate: () => Promise<DateTimeOutput>;
  registerOutDate: () => Promise<DateTimeOutput>;
  membershipState: () => Promise<String>;
  contact: <T = Contact>() => T;
  belongToEntity: <T = PartyEntity>() => T;
}

export interface PartyMembershipSubscription
  extends Promise<AsyncIterator<PartyMembershipNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  preEnrollDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  EnrollDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  registerInDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  registerOutDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  membershipState: () => Promise<AsyncIterator<String>>;
  contact: <T = ContactSubscription>() => T;
  belongToEntity: <T = PartyEntitySubscription>() => T;
}

export interface BanquetePreviousValuesNode {
  id: ID_Output;
  applicant: String;
  purpose: String;
  date: DateTimeOutput;
  description?: String;
  total: String;
  tags: String[];
}

export interface BanquetePreviousValues
  extends Promise<BanquetePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  applicant: () => Promise<String>;
  purpose: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  total: () => Promise<String>;
  tags: () => Promise<String[]>;
}

export interface BanquetePreviousValuesSubscription
  extends Promise<AsyncIterator<BanquetePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  applicant: () => Promise<AsyncIterator<String>>;
  purpose: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  total: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String[]>>;
}

export interface PersonEdgeNode {
  cursor: String;
}

export interface PersonEdge extends Promise<PersonEdgeNode>, Fragmentable {
  node: <T = Person>() => T;
  cursor: () => Promise<String>;
}

export interface PersonEdgeSubscription
  extends Promise<AsyncIterator<PersonEdgeNode>>,
    Fragmentable {
  node: <T = PersonSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BussinessTripConnectionNode {}

export interface BussinessTripConnection
  extends Promise<BussinessTripConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<BussinessTripEdgeNode>>() => T;
  aggregate: <T = AggregateBussinessTrip>() => T;
}

export interface BussinessTripConnectionSubscription
  extends Promise<AsyncIterator<BussinessTripConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BussinessTripEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBussinessTripSubscription>() => T;
}

export interface PartyEntityNode {
  id: ID_Output;
  name: String;
  fullName: String;
  startDate?: DateTimeOutput;
  endDate?: DateTimeOutput;
}

export interface PartyEntity extends Promise<PartyEntityNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  fullName: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
}

export interface PartyEntitySubscription
  extends Promise<AsyncIterator<PartyEntityNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  fullName: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BussinessTripSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface BussinessTripSubscriptionPayload
  extends Promise<BussinessTripSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BussinessTrip>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BussinessTripPreviousValues>() => T;
}

export interface BussinessTripSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BussinessTripSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BussinessTripSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BussinessTripPreviousValuesSubscription>() => T;
}

export interface AggregatePartyMembershipNode {
  count: Int;
}

export interface AggregatePartyMembership
  extends Promise<AggregatePartyMembershipNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePartyMembershipSubscription
  extends Promise<AsyncIterator<AggregatePartyMembershipNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BussinessTripPreviousValuesNode {
  id: ID_Output;
  purpose: String;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
  routes: String[];
  flightTicket: String;
  hotelRoom: String;
  transport: String;
}

export interface BussinessTripPreviousValues
  extends Promise<BussinessTripPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  purpose: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  routes: () => Promise<String[]>;
  flightTicket: () => Promise<String>;
  hotelRoom: () => Promise<String>;
  transport: () => Promise<String>;
}

export interface BussinessTripPreviousValuesSubscription
  extends Promise<AsyncIterator<BussinessTripPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  purpose: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  routes: () => Promise<AsyncIterator<String[]>>;
  flightTicket: () => Promise<AsyncIterator<String>>;
  hotelRoom: () => Promise<AsyncIterator<String>>;
  transport: () => Promise<AsyncIterator<String>>;
}

export interface PartyMembershipConnectionNode {}

export interface PartyMembershipConnection
  extends Promise<PartyMembershipConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<PartyMembershipEdgeNode>>() => T;
  aggregate: <T = AggregatePartyMembership>() => T;
}

export interface PartyMembershipConnectionSubscription
  extends Promise<AsyncIterator<PartyMembershipConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PartyMembershipEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePartyMembershipSubscription>() => T;
}

export interface DocumentNode {
  id: ID_Output;
  type?: String;
  mark?: String;
  classification?: String;
  startDate: DateTimeOutput;
  title: String;
  text: String;
  attachment?: String;
  tags?: String;
}

export interface Document extends Promise<DocumentNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  mark: () => Promise<String>;
  classification: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  text: () => Promise<String>;
  fromEntity: <T = Entity>() => T;
  sendingEntity: <T = Entity>() => T;
  toEntity: <T = Entity>() => T;
  copyEntity: <T = Entity>() => T;
  attachment: () => Promise<String>;
  tags: () => Promise<String>;
  author: <T = User>() => T;
}

export interface DocumentSubscription
  extends Promise<AsyncIterator<DocumentNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  mark: () => Promise<AsyncIterator<String>>;
  classification: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  fromEntity: <T = EntitySubscription>() => T;
  sendingEntity: <T = EntitySubscription>() => T;
  toEntity: <T = EntitySubscription>() => T;
  copyEntity: <T = EntitySubscription>() => T;
  attachment: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
}

export interface PartyEntityEdgeNode {
  cursor: String;
}

export interface PartyEntityEdge
  extends Promise<PartyEntityEdgeNode>,
    Fragmentable {
  node: <T = PartyEntity>() => T;
  cursor: () => Promise<String>;
}

export interface PartyEntityEdgeSubscription
  extends Promise<AsyncIterator<PartyEntityEdgeNode>>,
    Fragmentable {
  node: <T = PartyEntitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ContactSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ContactSubscriptionPayload
  extends Promise<ContactSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Contact>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContactPreviousValues>() => T;
}

export interface ContactSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContactSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContactSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContactPreviousValuesSubscription>() => T;
}

export interface AggregateLocationNode {
  count: Int;
}

export interface AggregateLocation
  extends Promise<AggregateLocationNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLocationSubscription
  extends Promise<AsyncIterator<AggregateLocationNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContactPreviousValuesNode {
  id: ID_Output;
  homePhone: String;
  officePhone: String;
  cellPhone: String;
  email: String;
  wechat?: String;
  whatsapp?: String;
  github?: String;
  twitter?: String;
  instagram?: String;
  homepage?: String;
  avatar?: String;
}

export interface ContactPreviousValues
  extends Promise<ContactPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  homePhone: () => Promise<String>;
  officePhone: () => Promise<String>;
  cellPhone: () => Promise<String>;
  email: () => Promise<String>;
  wechat: () => Promise<String>;
  whatsapp: () => Promise<String>;
  github: () => Promise<String>;
  twitter: () => Promise<String>;
  instagram: () => Promise<String>;
  homepage: () => Promise<String>;
  avatar: () => Promise<String>;
}

export interface ContactPreviousValuesSubscription
  extends Promise<AsyncIterator<ContactPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  homePhone: () => Promise<AsyncIterator<String>>;
  officePhone: () => Promise<AsyncIterator<String>>;
  cellPhone: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  wechat: () => Promise<AsyncIterator<String>>;
  whatsapp: () => Promise<AsyncIterator<String>>;
  github: () => Promise<AsyncIterator<String>>;
  twitter: () => Promise<AsyncIterator<String>>;
  instagram: () => Promise<AsyncIterator<String>>;
  homepage: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
}

export interface LocationConnectionNode {}

export interface LocationConnection
  extends Promise<LocationConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<LocationEdgeNode>>() => T;
  aggregate: <T = AggregateLocation>() => T;
}

export interface LocationConnectionSubscription
  extends Promise<AsyncIterator<LocationConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LocationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLocationSubscription>() => T;
}

export interface BussinessTripNode {
  id: ID_Output;
  purpose: String;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
  routes: String[];
  flightTicket: String;
  hotelRoom: String;
  transport: String;
}

export interface BussinessTrip
  extends Promise<BussinessTripNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  applicant: <T = FragmentableArray<UserNode>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  purpose: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  routes: () => Promise<String[]>;
  flightTicket: () => Promise<String>;
  hotelRoom: () => Promise<String>;
  transport: () => Promise<String>;
}

export interface BussinessTripSubscription
  extends Promise<AsyncIterator<BussinessTripNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  applicant: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  purpose: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  routes: () => Promise<AsyncIterator<String[]>>;
  flightTicket: () => Promise<AsyncIterator<String>>;
  hotelRoom: () => Promise<AsyncIterator<String>>;
  transport: () => Promise<AsyncIterator<String>>;
}

export interface ItemProcedureEdgeNode {
  cursor: String;
}

export interface ItemProcedureEdge
  extends Promise<ItemProcedureEdgeNode>,
    Fragmentable {
  node: <T = ItemProcedure>() => T;
  cursor: () => Promise<String>;
}

export interface ItemProcedureEdgeSubscription
  extends Promise<AsyncIterator<ItemProcedureEdgeNode>>,
    Fragmentable {
  node: <T = ItemProcedureSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DocumentSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface DocumentSubscriptionPayload
  extends Promise<DocumentSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Document>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DocumentPreviousValues>() => T;
}

export interface DocumentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DocumentSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DocumentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DocumentPreviousValuesSubscription>() => T;
}

export interface AggregateItemNode {
  count: Int;
}

export interface AggregateItem
  extends Promise<AggregateItemNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateItemSubscription
  extends Promise<AsyncIterator<AggregateItemNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DocumentPreviousValuesNode {
  id: ID_Output;
  type?: String;
  mark?: String;
  classification?: String;
  startDate: DateTimeOutput;
  title: String;
  text: String;
  attachment?: String;
  tags?: String;
}

export interface DocumentPreviousValues
  extends Promise<DocumentPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  mark: () => Promise<String>;
  classification: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  text: () => Promise<String>;
  attachment: () => Promise<String>;
  tags: () => Promise<String>;
}

export interface DocumentPreviousValuesSubscription
  extends Promise<AsyncIterator<DocumentPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  mark: () => Promise<AsyncIterator<String>>;
  classification: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  attachment: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String>>;
}

export interface ItemConnectionNode {}

export interface ItemConnection
  extends Promise<ItemConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ItemEdgeNode>>() => T;
  aggregate: <T = AggregateItem>() => T;
}

export interface ItemConnectionSubscription
  extends Promise<AsyncIterator<ItemConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateItemSubscription>() => T;
}

export interface AggregateBanqueteNode {
  count: Int;
}

export interface AggregateBanquete
  extends Promise<AggregateBanqueteNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBanqueteSubscription
  extends Promise<AsyncIterator<AggregateBanqueteNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ItemNode {
  id: ID_Output;
  name: String;
  brand: String;
  model: String;
  productionDate?: DateTimeOutput;
  overdueDate?: DateTimeOutput;
  description?: String;
  price: Float;
}

export interface Item extends Promise<ItemNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  brand: () => Promise<String>;
  model: () => Promise<String>;
  productionDate: () => Promise<DateTimeOutput>;
  overdueDate: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  price: () => Promise<Float>;
  mutationProcedure: <T = ItemProcedure>() => T;
}

export interface ItemSubscription
  extends Promise<AsyncIterator<ItemNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  brand: () => Promise<AsyncIterator<String>>;
  model: () => Promise<AsyncIterator<String>>;
  productionDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  overdueDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  mutationProcedure: <T = ItemProcedureSubscription>() => T;
}

export interface DocumentProcedureSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface DocumentProcedureSubscriptionPayload
  extends Promise<DocumentProcedureSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DocumentProcedure>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DocumentProcedurePreviousValues>() => T;
}

export interface DocumentProcedureSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DocumentProcedureSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DocumentProcedureSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DocumentProcedurePreviousValuesSubscription>() => T;
}

export interface EvaluationProcedureEdgeNode {
  cursor: String;
}

export interface EvaluationProcedureEdge
  extends Promise<EvaluationProcedureEdgeNode>,
    Fragmentable {
  node: <T = EvaluationProcedure>() => T;
  cursor: () => Promise<String>;
}

export interface EvaluationProcedureEdgeSubscription
  extends Promise<AsyncIterator<EvaluationProcedureEdgeNode>>,
    Fragmentable {
  node: <T = EvaluationProcedureSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DocumentProcedurePreviousValuesNode {
  id: ID_Output;
  from: String;
  to: String;
}

export interface DocumentProcedurePreviousValues
  extends Promise<DocumentProcedurePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  from: () => Promise<String>;
  to: () => Promise<String>;
}

export interface DocumentProcedurePreviousValuesSubscription
  extends Promise<AsyncIterator<DocumentProcedurePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  from: () => Promise<AsyncIterator<String>>;
  to: () => Promise<AsyncIterator<String>>;
}

export interface EvaluationProcedureNode {
  id: ID_Output;
  positiveObservation?: String;
  negativeObservation?: String;
  expectation?: String;
  performanceLevel: String;
  proposal?: String;
}

export interface EvaluationProcedure
  extends Promise<EvaluationProcedureNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  target: <T = User>() => T;
  positiveObservation: () => Promise<String>;
  negativeObservation: () => Promise<String>;
  expectation: () => Promise<String>;
  performanceLevel: () => Promise<String>;
  proposal: () => Promise<String>;
  directSuperior: <T = User>() => T;
  headOfInstitution: <T = User>() => T;
  procedureState: <T = Procedure>() => T;
}

export interface EvaluationProcedureSubscription
  extends Promise<AsyncIterator<EvaluationProcedureNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  target: <T = UserSubscription>() => T;
  positiveObservation: () => Promise<AsyncIterator<String>>;
  negativeObservation: () => Promise<AsyncIterator<String>>;
  expectation: () => Promise<AsyncIterator<String>>;
  performanceLevel: () => Promise<AsyncIterator<String>>;
  proposal: () => Promise<AsyncIterator<String>>;
  directSuperior: <T = UserSubscription>() => T;
  headOfInstitution: <T = UserSubscription>() => T;
  procedureState: <T = ProcedureSubscription>() => T;
}

export interface BanqueteEdgeNode {
  cursor: String;
}

export interface BanqueteEdge extends Promise<BanqueteEdgeNode>, Fragmentable {
  node: <T = Banquete>() => T;
  cursor: () => Promise<String>;
}

export interface BanqueteEdgeSubscription
  extends Promise<AsyncIterator<BanqueteEdgeNode>>,
    Fragmentable {
  node: <T = BanqueteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EntityEdgeNode {
  cursor: String;
}

export interface EntityEdge extends Promise<EntityEdgeNode>, Fragmentable {
  node: <T = Entity>() => T;
  cursor: () => Promise<String>;
}

export interface EntityEdgeSubscription
  extends Promise<AsyncIterator<EntityEdgeNode>>,
    Fragmentable {
  node: <T = EntitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EntitySubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface EntitySubscriptionPayload
  extends Promise<EntitySubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Entity>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EntityPreviousValues>() => T;
}

export interface EntitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EntitySubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EntitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EntityPreviousValuesSubscription>() => T;
}

export interface AggregateDocumentProcedureNode {
  count: Int;
}

export interface AggregateDocumentProcedure
  extends Promise<AggregateDocumentProcedureNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDocumentProcedureSubscription
  extends Promise<AsyncIterator<AggregateDocumentProcedureNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EntityPreviousValuesNode {
  id: ID_Output;
  name: String;
  fullName: String;
  abbr: String;
  avatar?: String;
}

export interface EntityPreviousValues
  extends Promise<EntityPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  fullName: () => Promise<String>;
  abbr: () => Promise<String>;
  avatar: () => Promise<String>;
}

export interface EntityPreviousValuesSubscription
  extends Promise<AsyncIterator<EntityPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  fullName: () => Promise<AsyncIterator<String>>;
  abbr: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
}

export interface DocumentProcedureConnectionNode {}

export interface DocumentProcedureConnection
  extends Promise<DocumentProcedureConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<DocumentProcedureEdgeNode>>() => T;
  aggregate: <T = AggregateDocumentProcedure>() => T;
}

export interface DocumentProcedureConnectionSubscription
  extends Promise<AsyncIterator<DocumentProcedureConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DocumentProcedureEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDocumentProcedureSubscription>() => T;
}

export interface BanqueteConnectionNode {}

export interface BanqueteConnection
  extends Promise<BanqueteConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<BanqueteEdgeNode>>() => T;
  aggregate: <T = AggregateBanquete>() => T;
}

export interface BanqueteConnectionSubscription
  extends Promise<AsyncIterator<BanqueteConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BanqueteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBanqueteSubscription>() => T;
}

export interface ActivityEdgeNode {
  cursor: String;
}

export interface ActivityEdge extends Promise<ActivityEdgeNode>, Fragmentable {
  node: <T = Activity>() => T;
  cursor: () => Promise<String>;
}

export interface ActivityEdgeSubscription
  extends Promise<AsyncIterator<ActivityEdgeNode>>,
    Fragmentable {
  node: <T = ActivitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EvaluationProcedureSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface EvaluationProcedureSubscriptionPayload
  extends Promise<EvaluationProcedureSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EvaluationProcedure>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EvaluationProcedurePreviousValues>() => T;
}

export interface EvaluationProcedureSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EvaluationProcedureSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EvaluationProcedureSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EvaluationProcedurePreviousValuesSubscription>() => T;
}

export interface VacationConnectionNode {}

export interface VacationConnection
  extends Promise<VacationConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<VacationEdgeNode>>() => T;
  aggregate: <T = AggregateVacation>() => T;
}

export interface VacationConnectionSubscription
  extends Promise<AsyncIterator<VacationConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VacationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVacationSubscription>() => T;
}

export interface EvaluationProcedurePreviousValuesNode {
  id: ID_Output;
  positiveObservation?: String;
  negativeObservation?: String;
  expectation?: String;
  performanceLevel: String;
  proposal?: String;
}

export interface EvaluationProcedurePreviousValues
  extends Promise<EvaluationProcedurePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  positiveObservation: () => Promise<String>;
  negativeObservation: () => Promise<String>;
  expectation: () => Promise<String>;
  performanceLevel: () => Promise<String>;
  proposal: () => Promise<String>;
}

export interface EvaluationProcedurePreviousValuesSubscription
  extends Promise<AsyncIterator<EvaluationProcedurePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  positiveObservation: () => Promise<AsyncIterator<String>>;
  negativeObservation: () => Promise<AsyncIterator<String>>;
  expectation: () => Promise<AsyncIterator<String>>;
  performanceLevel: () => Promise<AsyncIterator<String>>;
  proposal: () => Promise<AsyncIterator<String>>;
}

export interface VacationNode {
  id: ID_Output;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
  routes: Route;
  type: VacationType;
  flightTicket: String;
  hotelRoom: String;
  transport: String;
}

export interface Vacation extends Promise<VacationNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  applicant: <T = FragmentableArray<UserNode>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  routes: () => Promise<Route>;
  type: () => Promise<VacationType>;
  flightTicket: () => Promise<String>;
  hotelRoom: () => Promise<String>;
  transport: () => Promise<String>;
}

export interface VacationSubscription
  extends Promise<AsyncIterator<VacationNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  applicant: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  routes: () => Promise<AsyncIterator<Route>>;
  type: () => Promise<AsyncIterator<VacationType>>;
  flightTicket: () => Promise<AsyncIterator<String>>;
  hotelRoom: () => Promise<AsyncIterator<String>>;
  transport: () => Promise<AsyncIterator<String>>;
}

export interface EntityNode {
  id: ID_Output;
  name: String;
  fullName: String;
  abbr: String;
  avatar?: String;
}

export interface Entity extends Promise<EntityNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  fullName: () => Promise<String>;
  abbr: () => Promise<String>;
  address: <T = Address>() => T;
  avatar: () => Promise<String>;
}

export interface EntitySubscription
  extends Promise<AsyncIterator<EntityNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  fullName: () => Promise<AsyncIterator<String>>;
  abbr: () => Promise<AsyncIterator<String>>;
  address: <T = AddressSubscription>() => T;
  avatar: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTransactionNode {
  count: Int;
}

export interface AggregateTransaction
  extends Promise<AggregateTransactionNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTransactionSubscription
  extends Promise<AsyncIterator<AggregateTransactionNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ItemSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ItemSubscriptionPayload
  extends Promise<ItemSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Item>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ItemPreviousValues>() => T;
}

export interface ItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ItemSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ItemPreviousValuesSubscription>() => T;
}

export interface UserSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayload
  extends Promise<UserSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = User>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValues>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface ItemPreviousValuesNode {
  id: ID_Output;
  name: String;
  brand: String;
  model: String;
  productionDate?: DateTimeOutput;
  overdueDate?: DateTimeOutput;
  description?: String;
  price: Float;
}

export interface ItemPreviousValues
  extends Promise<ItemPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  brand: () => Promise<String>;
  model: () => Promise<String>;
  productionDate: () => Promise<DateTimeOutput>;
  overdueDate: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  price: () => Promise<Float>;
}

export interface ItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ItemPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  brand: () => Promise<AsyncIterator<String>>;
  model: () => Promise<AsyncIterator<String>>;
  productionDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  overdueDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
}

export interface StorageConnectionNode {}

export interface StorageConnection
  extends Promise<StorageConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<StorageEdgeNode>>() => T;
  aggregate: <T = AggregateStorage>() => T;
}

export interface StorageConnectionSubscription
  extends Promise<AsyncIterator<StorageConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StorageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStorageSubscription>() => T;
}

export interface BanqueteNode {
  id: ID_Output;
  applicant: String;
  purpose: String;
  date: DateTimeOutput;
  description?: String;
  total: String;
  tags: String[];
}

export interface Banquete extends Promise<BanqueteNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  applicant: () => Promise<String>;
  purpose: () => Promise<String>;
  offerer: <T = User>() => T;
  authorizer: <T = User>() => T;
  companions: <T = FragmentableArray<UserNode>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  guests: <T = FragmentableArray<UserNode>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  place: <T = Entity>() => T;
  date: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  total: () => Promise<String>;
  tags: () => Promise<String[]>;
}

export interface BanqueteSubscription
  extends Promise<AsyncIterator<BanqueteNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  applicant: () => Promise<AsyncIterator<String>>;
  purpose: () => Promise<AsyncIterator<String>>;
  offerer: <T = UserSubscription>() => T;
  authorizer: <T = UserSubscription>() => T;
  companions: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  guests: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  place: <T = EntitySubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  total: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String[]>>;
}

export interface PromotionProcedureEdgeNode {
  cursor: String;
}

export interface PromotionProcedureEdge
  extends Promise<PromotionProcedureEdgeNode>,
    Fragmentable {
  node: <T = PromotionProcedure>() => T;
  cursor: () => Promise<String>;
}

export interface PromotionProcedureEdgeSubscription
  extends Promise<AsyncIterator<PromotionProcedureEdgeNode>>,
    Fragmentable {
  node: <T = PromotionProcedureSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ItemProcedureSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ItemProcedureSubscriptionPayload
  extends Promise<ItemProcedureSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ItemProcedure>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ItemProcedurePreviousValues>() => T;
}

export interface ItemProcedureSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ItemProcedureSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ItemProcedureSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ItemProcedurePreviousValuesSubscription>() => T;
}

export interface AggregateProcedureNode {
  count: Int;
}

export interface AggregateProcedure
  extends Promise<AggregateProcedureNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProcedureSubscription
  extends Promise<AsyncIterator<AggregateProcedureNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ItemProcedurePreviousValuesNode {
  id: ID_Output;
  previousPlace: String;
  currentPlace: String;
  devaluation: String;
}

export interface ItemProcedurePreviousValues
  extends Promise<ItemProcedurePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  previousPlace: () => Promise<String>;
  currentPlace: () => Promise<String>;
  devaluation: () => Promise<String>;
}

export interface ItemProcedurePreviousValuesSubscription
  extends Promise<AsyncIterator<ItemProcedurePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  previousPlace: () => Promise<AsyncIterator<String>>;
  currentPlace: () => Promise<AsyncIterator<String>>;
  devaluation: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePersonNode {
  count: Int;
}

export interface AggregatePerson
  extends Promise<AggregatePersonNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePersonSubscription
  extends Promise<AsyncIterator<AggregatePersonNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateArticleNode {
  count: Int;
}

export interface AggregateArticle
  extends Promise<AggregateArticleNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateArticleSubscription
  extends Promise<AsyncIterator<AggregateArticleNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PersonNode {
  id: ID_Output;
  name: String;
  gender: String;
  birthday: DateTimeOutput;
}

export interface Person extends Promise<PersonNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  gender: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
}

export interface PersonSubscription
  extends Promise<AsyncIterator<PersonNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LocationSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface LocationSubscriptionPayload
  extends Promise<LocationSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Location>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LocationPreviousValues>() => T;
}

export interface LocationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LocationSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LocationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LocationPreviousValuesSubscription>() => T;
}

export interface AggregatePartyEntityNode {
  count: Int;
}

export interface AggregatePartyEntity
  extends Promise<AggregatePartyEntityNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePartyEntitySubscription
  extends Promise<AsyncIterator<AggregatePartyEntityNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LocationPreviousValuesNode {
  id: ID_Output;
  latitude: Float;
  longitude: Float;
}

export interface LocationPreviousValues
  extends Promise<LocationPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  latitude: () => Promise<Float>;
  longitude: () => Promise<Float>;
}

export interface LocationPreviousValuesSubscription
  extends Promise<AsyncIterator<LocationPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  latitude: () => Promise<AsyncIterator<Float>>;
  longitude: () => Promise<AsyncIterator<Float>>;
}

export interface LocationEdgeNode {
  cursor: String;
}

export interface LocationEdge extends Promise<LocationEdgeNode>, Fragmentable {
  node: <T = Location>() => T;
  cursor: () => Promise<String>;
}

export interface LocationEdgeSubscription
  extends Promise<AsyncIterator<LocationEdgeNode>>,
    Fragmentable {
  node: <T = LocationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ArticleEdgeNode {
  cursor: String;
}

export interface ArticleEdge extends Promise<ArticleEdgeNode>, Fragmentable {
  node: <T = Article>() => T;
  cursor: () => Promise<String>;
}

export interface ArticleEdgeSubscription
  extends Promise<AsyncIterator<ArticleEdgeNode>>,
    Fragmentable {
  node: <T = ArticleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ItemProcedureConnectionNode {}

export interface ItemProcedureConnection
  extends Promise<ItemProcedureConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ItemProcedureEdgeNode>>() => T;
  aggregate: <T = AggregateItemProcedure>() => T;
}

export interface ItemProcedureConnectionSubscription
  extends Promise<AsyncIterator<ItemProcedureConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ItemProcedureEdgeSubscription>>>() => T;
  aggregate: <T = AggregateItemProcedureSubscription>() => T;
}

export interface PartyEntitySubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PartyEntitySubscriptionPayload
  extends Promise<PartyEntitySubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PartyEntity>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PartyEntityPreviousValues>() => T;
}

export interface PartyEntitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PartyEntitySubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PartyEntitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PartyEntityPreviousValuesSubscription>() => T;
}

export interface ItemProcedureNode {
  id: ID_Output;
  previousPlace: String;
  currentPlace: String;
  devaluation: String;
}

export interface ItemProcedure
  extends Promise<ItemProcedureNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  previousPlace: () => Promise<String>;
  currentPlace: () => Promise<String>;
  devaluation: () => Promise<String>;
  procedureState: <T = Procedure>() => T;
}

export interface ItemProcedureSubscription
  extends Promise<AsyncIterator<ItemProcedureNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  previousPlace: () => Promise<AsyncIterator<String>>;
  currentPlace: () => Promise<AsyncIterator<String>>;
  devaluation: () => Promise<AsyncIterator<String>>;
  procedureState: <T = ProcedureSubscription>() => T;
}

export interface PartyEntityPreviousValuesNode {
  id: ID_Output;
  name: String;
  fullName: String;
  startDate?: DateTimeOutput;
  endDate?: DateTimeOutput;
}

export interface PartyEntityPreviousValues
  extends Promise<PartyEntityPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  fullName: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
}

export interface PartyEntityPreviousValuesSubscription
  extends Promise<AsyncIterator<PartyEntityPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  fullName: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EvaluationProcedureConnectionNode {}

export interface EvaluationProcedureConnection
  extends Promise<EvaluationProcedureConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<EvaluationProcedureEdgeNode>>() => T;
  aggregate: <T = AggregateEvaluationProcedure>() => T;
}

export interface EvaluationProcedureConnectionSubscription
  extends Promise<AsyncIterator<EvaluationProcedureConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<EvaluationProcedureEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateEvaluationProcedureSubscription>() => T;
}

export interface ArticleConnectionNode {}

export interface ArticleConnection
  extends Promise<ArticleConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ArticleEdgeNode>>() => T;
  aggregate: <T = AggregateArticle>() => T;
}

export interface ArticleConnectionSubscription
  extends Promise<AsyncIterator<ArticleConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ArticleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateArticleSubscription>() => T;
}

export interface EntityConnectionNode {}

export interface EntityConnection
  extends Promise<EntityConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<EntityEdgeNode>>() => T;
  aggregate: <T = AggregateEntity>() => T;
}

export interface EntityConnectionSubscription
  extends Promise<AsyncIterator<EntityConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EntityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEntitySubscription>() => T;
}

export interface PartyMembershipSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PartyMembershipSubscriptionPayload
  extends Promise<PartyMembershipSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PartyMembership>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PartyMembershipPreviousValues>() => T;
}

export interface PartyMembershipSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PartyMembershipSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PartyMembershipSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PartyMembershipPreviousValuesSubscription>() => T;
}

export interface ProcedureNode {
  id: ID_Output;
  name: String;
  startDate: DateTimeOutput;
  deadline?: DateTimeOutput;
  progress?: Float;
  color?: String;
}

export interface Procedure extends Promise<ProcedureNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  deadline: () => Promise<DateTimeOutput>;
  progress: () => Promise<Float>;
  color: () => Promise<String>;
  previousProcedure: <T = Procedure>() => T;
  nextProcedure: <T = Procedure>() => T;
  users: <T = FragmentableArray<UserNode>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  documents: <T = FragmentableArray<DocumentNode>>(
    args?: {
      where?: DocumentWhereInput;
      orderBy?: DocumentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  entities: <T = FragmentableArray<EntityNode>>(
    args?: {
      where?: EntityWhereInput;
      orderBy?: EntityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ProcedureSubscription
  extends Promise<AsyncIterator<ProcedureNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  deadline: () => Promise<AsyncIterator<DateTimeOutput>>;
  progress: () => Promise<AsyncIterator<Float>>;
  color: () => Promise<AsyncIterator<String>>;
  previousProcedure: <T = ProcedureSubscription>() => T;
  nextProcedure: <T = ProcedureSubscription>() => T;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  documents: <T = Promise<AsyncIterator<DocumentSubscription>>>(
    args?: {
      where?: DocumentWhereInput;
      orderBy?: DocumentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  entities: <T = Promise<AsyncIterator<EntitySubscription>>>(
    args?: {
      where?: EntityWhereInput;
      orderBy?: EntityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PartyMembershipPreviousValuesNode {
  id: ID_Output;
  name: String;
  preEnrollDate: DateTimeOutput;
  EnrollDate: DateTimeOutput;
  registerInDate: DateTimeOutput;
  registerOutDate: DateTimeOutput;
  membershipState: String;
}

export interface PartyMembershipPreviousValues
  extends Promise<PartyMembershipPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  preEnrollDate: () => Promise<DateTimeOutput>;
  EnrollDate: () => Promise<DateTimeOutput>;
  registerInDate: () => Promise<DateTimeOutput>;
  registerOutDate: () => Promise<DateTimeOutput>;
  membershipState: () => Promise<String>;
}

export interface PartyMembershipPreviousValuesSubscription
  extends Promise<AsyncIterator<PartyMembershipPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  preEnrollDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  EnrollDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  registerInDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  registerOutDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  membershipState: () => Promise<AsyncIterator<String>>;
}

export interface AggregateActivityNode {
  count: Int;
}

export interface AggregateActivity
  extends Promise<AggregateActivityNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActivitySubscription
  extends Promise<AsyncIterator<AggregateActivityNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ActivityConnectionNode {}

export interface ActivityConnection
  extends Promise<ActivityConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ActivityEdgeNode>>() => T;
  aggregate: <T = AggregateActivity>() => T;
}

export interface ActivityConnectionSubscription
  extends Promise<AsyncIterator<ActivityConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ActivityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateActivitySubscription>() => T;
}

export interface TransactionConnectionNode {}

export interface TransactionConnection
  extends Promise<TransactionConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<TransactionEdgeNode>>() => T;
  aggregate: <T = AggregateTransaction>() => T;
}

export interface TransactionConnectionSubscription
  extends Promise<AsyncIterator<TransactionConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TransactionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTransactionSubscription>() => T;
}

export interface PersonSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PersonSubscriptionPayload
  extends Promise<PersonSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Person>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PersonPreviousValues>() => T;
}

export interface PersonSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PersonSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PersonSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PersonPreviousValuesSubscription>() => T;
}

export interface StorageNode {
  id: ID_Output;
  storageName: String;
}

export interface Storage extends Promise<StorageNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  storageName: () => Promise<String>;
  guardName: <T = User>() => T;
  items: <T = FragmentableArray<ItemNode>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface StorageSubscription
  extends Promise<AsyncIterator<StorageNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  storageName: () => Promise<AsyncIterator<String>>;
  guardName: <T = UserSubscription>() => T;
  items: <T = Promise<AsyncIterator<ItemSubscription>>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PersonPreviousValuesNode {
  id: ID_Output;
  name: String;
  gender: String;
  birthday: DateTimeOutput;
}

export interface PersonPreviousValues
  extends Promise<PersonPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  gender: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
}

export interface PersonPreviousValuesSubscription
  extends Promise<AsyncIterator<PersonPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProcedureConnectionNode {}

export interface ProcedureConnection
  extends Promise<ProcedureConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ProcedureEdgeNode>>() => T;
  aggregate: <T = AggregateProcedure>() => T;
}

export interface ProcedureConnectionSubscription
  extends Promise<AsyncIterator<ProcedureConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProcedureEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProcedureSubscription>() => T;
}

export interface ArticleNode {
  id: ID_Output;
  author: String;
  title: String;
  tags: String[];
  isPublished: Boolean;
  description?: String;
  text?: String;
  featuredImage?: String;
  format?: ArticleFormat;
  publishDate: DateTimeOutput;
}

export interface Article extends Promise<ArticleNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  author: () => Promise<String>;
  title: () => Promise<String>;
  tags: () => Promise<String[]>;
  isPublished: () => Promise<Boolean>;
  description: () => Promise<String>;
  text: () => Promise<String>;
  featuredImage: () => Promise<String>;
  format: () => Promise<ArticleFormat>;
  publishDate: () => Promise<DateTimeOutput>;
}

export interface ArticleSubscription
  extends Promise<AsyncIterator<ArticleNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  author: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String[]>>;
  isPublished: () => Promise<AsyncIterator<Boolean>>;
  description: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  featuredImage: () => Promise<AsyncIterator<String>>;
  format: () => Promise<AsyncIterator<ArticleFormat>>;
  publishDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PartyMembershipEdgeNode {
  cursor: String;
}

export interface PartyMembershipEdge
  extends Promise<PartyMembershipEdgeNode>,
    Fragmentable {
  node: <T = PartyMembership>() => T;
  cursor: () => Promise<String>;
}

export interface PartyMembershipEdgeSubscription
  extends Promise<AsyncIterator<PartyMembershipEdgeNode>>,
    Fragmentable {
  node: <T = PartyMembershipSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProcedureSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ProcedureSubscriptionPayload
  extends Promise<ProcedureSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Procedure>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProcedurePreviousValues>() => T;
}

export interface ProcedureSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProcedureSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProcedureSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProcedurePreviousValuesSubscription>() => T;
}

export interface AggregateItemProcedureNode {
  count: Int;
}

export interface AggregateItemProcedure
  extends Promise<AggregateItemProcedureNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateItemProcedureSubscription
  extends Promise<AsyncIterator<AggregateItemProcedureNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProcedurePreviousValuesNode {
  id: ID_Output;
  name: String;
  startDate: DateTimeOutput;
  deadline?: DateTimeOutput;
  progress?: Float;
  color?: String;
}

export interface ProcedurePreviousValues
  extends Promise<ProcedurePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  deadline: () => Promise<DateTimeOutput>;
  progress: () => Promise<Float>;
  color: () => Promise<String>;
}

export interface ProcedurePreviousValuesSubscription
  extends Promise<AsyncIterator<ProcedurePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  deadline: () => Promise<AsyncIterator<DateTimeOutput>>;
  progress: () => Promise<AsyncIterator<Float>>;
  color: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEvaluationProcedureNode {
  count: Int;
}

export interface AggregateEvaluationProcedure
  extends Promise<AggregateEvaluationProcedureNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEvaluationProcedureSubscription
  extends Promise<AsyncIterator<AggregateEvaluationProcedureNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateAddressNode {
  count: Int;
}

export interface AggregateAddress
  extends Promise<AggregateAddressNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAddressSubscription
  extends Promise<AsyncIterator<AggregateAddressNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DocumentProcedureEdgeNode {
  cursor: String;
}

export interface DocumentProcedureEdge
  extends Promise<DocumentProcedureEdgeNode>,
    Fragmentable {
  node: <T = DocumentProcedure>() => T;
  cursor: () => Promise<String>;
}

export interface DocumentProcedureEdgeSubscription
  extends Promise<AsyncIterator<DocumentProcedureEdgeNode>>,
    Fragmentable {
  node: <T = DocumentProcedureSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PromotionProcedureSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PromotionProcedureSubscriptionPayload
  extends Promise<PromotionProcedureSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PromotionProcedure>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PromotionProcedurePreviousValues>() => T;
}

export interface PromotionProcedureSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PromotionProcedureSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PromotionProcedureSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PromotionProcedurePreviousValuesSubscription>() => T;
}

export interface UserEdgeNode {
  cursor: String;
}

export interface UserEdge extends Promise<UserEdgeNode>, Fragmentable {
  node: <T = User>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdgeNode>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PromotionProcedurePreviousValuesNode {
  id: ID_Output;
  previousRank: String;
  currentRank: String;
  promitionDate: DateTimeOutput;
  previousSalary: String;
  currentSalary: String;
}

export interface PromotionProcedurePreviousValues
  extends Promise<PromotionProcedurePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  previousRank: () => Promise<String>;
  currentRank: () => Promise<String>;
  promitionDate: () => Promise<DateTimeOutput>;
  previousSalary: () => Promise<String>;
  currentSalary: () => Promise<String>;
}

export interface PromotionProcedurePreviousValuesSubscription
  extends Promise<AsyncIterator<PromotionProcedurePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  previousRank: () => Promise<AsyncIterator<String>>;
  currentRank: () => Promise<AsyncIterator<String>>;
  promitionDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  previousSalary: () => Promise<AsyncIterator<String>>;
  currentSalary: () => Promise<AsyncIterator<String>>;
}

export interface ContactNode {
  id: ID_Output;
  homePhone: String;
  officePhone: String;
  cellPhone: String;
  email: String;
  wechat?: String;
  whatsapp?: String;
  github?: String;
  twitter?: String;
  instagram?: String;
  homepage?: String;
  avatar?: String;
}

export interface Contact extends Promise<ContactNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  homePhone: () => Promise<String>;
  officePhone: () => Promise<String>;
  cellPhone: () => Promise<String>;
  email: () => Promise<String>;
  wechat: () => Promise<String>;
  whatsapp: () => Promise<String>;
  github: () => Promise<String>;
  twitter: () => Promise<String>;
  instagram: () => Promise<String>;
  homepage: () => Promise<String>;
  avatar: () => Promise<String>;
}

export interface ContactSubscription
  extends Promise<AsyncIterator<ContactNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  homePhone: () => Promise<AsyncIterator<String>>;
  officePhone: () => Promise<AsyncIterator<String>>;
  cellPhone: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  wechat: () => Promise<AsyncIterator<String>>;
  whatsapp: () => Promise<AsyncIterator<String>>;
  github: () => Promise<AsyncIterator<String>>;
  twitter: () => Promise<AsyncIterator<String>>;
  instagram: () => Promise<AsyncIterator<String>>;
  homepage: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
}

export interface AddressEdgeNode {
  cursor: String;
}

export interface AddressEdge extends Promise<AddressEdgeNode>, Fragmentable {
  node: <T = Address>() => T;
  cursor: () => Promise<String>;
}

export interface AddressEdgeSubscription
  extends Promise<AsyncIterator<AddressEdgeNode>>,
    Fragmentable {
  node: <T = AddressSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PartyEntityConnectionNode {}

export interface PartyEntityConnection
  extends Promise<PartyEntityConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<PartyEntityEdgeNode>>() => T;
  aggregate: <T = AggregatePartyEntity>() => T;
}

export interface PartyEntityConnectionSubscription
  extends Promise<AsyncIterator<PartyEntityConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PartyEntityEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePartyEntitySubscription>() => T;
}

export interface AggregateEntityNode {
  count: Int;
}

export interface AggregateEntity
  extends Promise<AggregateEntityNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEntitySubscription
  extends Promise<AsyncIterator<AggregateEntityNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TransactionSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface TransactionSubscriptionPayload
  extends Promise<TransactionSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Transaction>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TransactionPreviousValues>() => T;
}

export interface TransactionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TransactionSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TransactionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TransactionPreviousValuesSubscription>() => T;
}

export interface AddressConnectionNode {}

export interface AddressConnection
  extends Promise<AddressConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<AddressEdgeNode>>() => T;
  aggregate: <T = AggregateAddress>() => T;
}

export interface AddressConnectionSubscription
  extends Promise<AsyncIterator<AddressConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AddressEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAddressSubscription>() => T;
}

export interface StoragePreviousValuesNode {
  id: ID_Output;
  storageName: String;
}

export interface StoragePreviousValues
  extends Promise<StoragePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  storageName: () => Promise<String>;
}

export interface StoragePreviousValuesSubscription
  extends Promise<AsyncIterator<StoragePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  storageName: () => Promise<AsyncIterator<String>>;
}

export interface StorageSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface StorageSubscriptionPayload
  extends Promise<StorageSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Storage>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StoragePreviousValues>() => T;
}

export interface StorageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StorageSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StorageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StoragePreviousValuesSubscription>() => T;
}

export interface AggregateVacationNode {
  count: Int;
}

export interface AggregateVacation
  extends Promise<AggregateVacationNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVacationSubscription
  extends Promise<AsyncIterator<AggregateVacationNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ItemEdgeNode {
  cursor: String;
}

export interface ItemEdge extends Promise<ItemEdgeNode>, Fragmentable {
  node: <T = Item>() => T;
  cursor: () => Promise<String>;
}

export interface ItemEdgeSubscription
  extends Promise<AsyncIterator<ItemEdgeNode>>,
    Fragmentable {
  node: <T = ItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PersonConnectionNode {}

export interface PersonConnection
  extends Promise<PersonConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<PersonEdgeNode>>() => T;
  aggregate: <T = AggregatePerson>() => T;
}

export interface PersonConnectionSubscription
  extends Promise<AsyncIterator<PersonConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PersonEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePersonSubscription>() => T;
}

export interface AggregateStorageNode {
  count: Int;
}

export interface AggregateStorage
  extends Promise<AggregateStorageNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStorageSubscription
  extends Promise<AsyncIterator<AggregateStorageNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  endpoint: `https://eu1.prisma.sh/wenju-xing-3d984a/demo/dev`
});
export const prisma = new Prisma();
